# 数据结构--查找

## 顺序查找

顺序查找适合于顺序表和链表，**属于无序查找**，**从后往前开始**

- **找第i个元素需要比较的次数：n-i+1**
- **如果要找的不在表中则比较次数为（查找失败）：n+1**
- **长度为n的顺序表，查找任一元素平均查找长度为(ASL)：(n+1)/2**
  - **若题目中没说是顺序表则平均查找长度为n/2**

- **时间复杂度：0(n)**

**优缺点：适用范围大，元素无次序  ，当n较大时效率较低**

 **注意：**

- **单链表和顺序表实现时间复杂度都为O(n)，但**
- **删除第一个元素时，单链表可直接删除不需要移动元素，而顺序表删完后需要移动元素，所需时间更多，故此情况下单链表时间快**
- **若在最后一个元素插入一个新的元素，单链表需要遍历到最后一个元素才能进行插入，而顺序表仅需根据下标即可，不需要移动元素，即顺序表速度大于单链表速度**
- **若交换两个元素，单链表均需要遍历到该元素位置才能完成交换，而顺序表无需遍历，仅根据下标即可完成，故顺序表速度快**



## 折半查找 （二分查找） ┗   ┛   ┏    ┓

**适用于有序查找** 

**<span style="text-decoration:line-through;">查找成功的平均查找长度ASL ≈ log₂(n+1)-1</span>，时间复杂度为O（log₂n）**

**【注：若题目中问平均查找长度一般用判定树来进行计算，查找成功长度为（每层结点个数 * 树的层数）/结点个数】**

- 确定中间位置为mid =  **┗  (low+high)  / 2 ┛（向下取整）**
- **若中间位置等于待查数字之4则查找成功，若中间位置值小于待查数字值，则low = mid + 1    若中间位置值大于待查数字值，则high = mid - 1**

**优缺点：比较次数少，查找速度相对快，查找前需要建立有序表，适用范围少，并不是一定比顺序查找速度快**

### 折半查找判定树

**折半查找判定树是一颗平衡二叉树，其核心思想同二叉排序树一致，（核心思想：中间大的放中间，最小的放左子树，最大的放右子树）**

**判定树的高度为：h =   ┗ log₂n ┛  + 1 或者 h = ┏ log₂(n+1) ┓，比较成功时，同关键字比较次数最多为h，时间复杂度为O（log₂n）**

例，若有1000个元素，则采用折半查找则至多比较 **┏ log₂(1000+1) ┓次**数

#### 构建判定树快速法

1. **根据元素数量，画出二叉树，每次先画右子树，把每行的右结点的右子树都画完时，再画左结点的右子树，当每行右子树都画完时，然后再按量添加左子树（均是从右往左）**
2. **画完二叉树，然后按照有序序列的中序便利进行填充**

**补充：**

- **查找元素需要与哪些元素进行比较时，可按照二叉排序树的插入进行比较，（从根节点开始，若大于根节点则从右子树开始比较，若小于根节点则从左子树开始比较，依次递归，直到查找完成）**
- **其中ASL查找成功和失败按照二叉排序树的查找成功失败来进行计算**

## 分块查找（索引查找）

**分块查找又成索引顺序查找，原始序列可以无序，将其进行分块，不一定要进行等分，选择每个块中最大的元素放入一张索引表，并记录该元素的地址，索引表内元素需有序**

**若表长度为n，每个子表的长度相等，设为s，则进行成功查找的平均查找长度为：(k+n/k) / 2 +1**



## 树型查找

二叉排序树与平衡二叉树在之前章节

【**补充**】：

- **二叉排序树的进行中序遍历，得到的结点序列一定是个有序序列**

- **n个结点的二叉排序树，平均情况时间复杂度为O（log₂n）,最坏情况下为O(n)**

### B树和B+树（最后弄）

## 散列查找

**与N无关**