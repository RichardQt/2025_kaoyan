# 专业课真题小题考点

## 基础考点

- **评价算法应该从<span style="color:#FF0000;">正确性、可读性、健壮性、高效率与低存储</span>需求来考虑**
- **算法具有<span style="color:#FF0000;">有穷性、确定性</span>、可行性、输入、输出**
- **数据结构包含：存储结构、逻辑结构和<span style="color:#FF0000;">数据的运算</span>。**
- **数据的存储结构主要有<span style="color:#FF0000;">顺序存储、链式存储、索引存储、散列存储</span>**
- **记录是文件中可存取的基本单位，数据项是文件中可使用的最小单位**
- **数据结构中被定义成（K, B），其中 K 是 <u> <span style="color:#FF0000;"> 数据元素 </span> </u> 的有限集合，R 是 K 上的关系有限集合**
  - **数据结构是带有结构的数据元素集合**

- **<span style="color:#FF0000;">数据元素是数据基本单位</span>，<span style="color:#FF0000;"> 一个数据元素可用若干数据项组成 </span>**，<span style="color:#FF0000;">数据项是数据的不可分割的最小单位</span>
- :star:**抽象数据类型一个特点是抽象数据类型的用户看不到抽象数据类型的 <u> 数据存储 </u> 及其 <u> 操作 </u> 的实现**
  - **一个抽象数据类型包括数据元素，元素之间的关系以及 <u> <span style="color:#FF3333;"> 元素的操作 </span> </u>**
  - **一个抽象数据类型 <span style="color:#FF0000;"> 包括数据和操作两个部分 </span>**
  - **抽象数据类型是指数据逻辑结构与之相关的<span style="color:#FF0000;">一组运算</span>**
  
- **数据对象：具有<span style="color:#FF0000;">相同特征的数据元素的集合</span>**
- **逻辑结构包含：线型和非线型，其中非线型包括：集合、树型、图型。**
- **算法的五个特征：**
  - **有穷性：保证在 <span style="color:#FF0000;"> 有限步骤 </span> 之后结束，并不是无限** 
  - **确定性**：算法每一个指令都必须有明确的含义 不能是模棱两可
  - **可行性：每个操作步骤的必须在 <span style="color:#FF0000;"> 有限时间 </span> 完成**
  - 输入：算法可以有一个或多个输入，也可以没有输入
  - 输出：可以有一个或多个输出，没有输出的算法是没有意义的

### c 语言

- **在 C 语言中整型、字符型、float 型之间关系：整型+float 型 = float 型 、整型 *字符型 = 整型 、字符型+float 型 = float 型**
  - <span style="color:#FF0000;">**从大到小关系为：float 型 > 整型 > 字符型（大吃小）**</span>
- **if 语句后面的判断条件可以跟<span style="color:#FF0000;">任意表达式</span>**
- **常量指针不能进行自增或自减运算；`&s` 返回的是整个数组的地址，也不能进行加减运算**
- **文本文件存储**：
- eg：-8765 在文本文件中存储为字符串 "-8765"，包含 5 个字符：负号(1 字节) + 8(1 字节) + 7(1 字节) + 6(1 字节) + 5(1 字节)
  - **<span style="color:#FF0000;">每个 ASCII 字符占 1 字节</span>，共需 5 字节**

- **二进制文件存储：**
- **-8765 用二进制存储时，因为在 16 位整型范围，只需要 2 字节(16 位)就能表示 [-32768, 32767]**

#### 运算符表达式？？？？

#### 指针

- :star::warning:**:warning:设 int b [3] [ 3 ]; 则数组元素 b [1] [2] 用指针表示为：` *(*(b + 1) + 2) ` **
  - **本题解题步骤：**
    - **`b+i` => 指针 `b` 向后移动 `i` 行。**
    - **`*(b+i)` 表示对 i 行的首地址**
    - **`*(b + 1) + 2` 表示第 1 行第 2 列元素的地址**
    - **`*(*(b + 1) + 2)` 表示对第一行第二列元素解引用，即取值**
  - <span style="color:#FF0000;"> **即 `b[i][j]` 用指针表示为：`*(*(b + i) + j)`**</span>
  - **补充知识点：**
    - **<span style="color:#FF0000;">一维数组：数组名是指向第一个元素的指针</span>**。**<span style="color:#FF0000;">二维数组：数组名是指向数组第一行的指针，即 b [0] 的指针</span>。**
  
- **对于一个具 n 个结点的线性链表，在已知的结点 `*p` 后插入一个新结点的时间复杂性为 O(1)**
  
  - **已知  *p（若改为&p 一样），意味着我们已经有办法直接访问到 p 所指向的内存地址，则不用遍历到该结点所在位置**。
  
  
  
- <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231657287.png" alt="image-20241123165741239" style="zoom:80%;" /> **解析：因为 <span style="color:#FF0000;"> s 是二级指针，不能直接赋值字符串常量，只能有 `*s = "hello"` 或 `**s = 'h'`  </span>**
  
  - **若题目改成一级指针 char *s，`*S` 表示 `S` 所指向的地址的内容，默认指向第一个字母 ，则正确的语句为 <span style="color:#FF3333;"> `*s = 'h'`</span>**



## 线性表

- **:warning: 个元素的线性表第 i 个位置<span style="color:#FF0000;">插入元素，平均移动 `n/2` 次，需移动 `n-i+1 ` 次元素</span>**
- **删除含 n 个元素的线性表第 i 个位置的元素，<span style="color:#FF0000;">平均移动 `(n-1)/2` 次</span>，需移动 `n-i` 次元素**
- **<span style="color:#FF0000;"> 在插入或删除第一个元素 </span> 时单链表比顺序表效率高，单链表无需移动元素，仅需修改指针，时间复杂度 O(1)**
  - **若单链表删除中间元素或尾部则 <span style="color:#FF0000;"> 需要遍历到该元素才能进行删除 </span>，故没有线性表高效**
  - <span style="color:#FF0000;">**总结：链式存储在插入和删除操作方面具有较高的效率，只需要修改指针链接即可。而顺序存储在插入和删除操作方面效率较低，因为它需要移动大量元素以保持数据的连续性**</span>
    - <span style="color:#FF0000;">**顺序表适宜于做查找这样的静态操作，顺序存储：访问某一结点、查找某结点前驱、删除尾结点的时间复杂度都是O（1）**</span>
- :star:**链式存储设计时，<span style="color:#FF0000;">结点内的存储单元地址一定连续</span>，结点外的存储单元地址可以是任意的**

**总结**

- 线性表插入 平均移动n/2 需移动n-i+1    删除 平均移动n-1 /2 需移动n-i 

### :star:链表

**:warning:等号前面->要理解成指针，等号后面->理解成结点**  

**e.g. p->next=q->next  是指P的后继指针指向q的后继结点即P后继指向D**

**p-> Prior-> next = P-> next  是理解成p的前驱结点A的后继指针指向P的后继结点C**



1. **在一个附设头结点的双向链表中删除 P 所指结点的操作是：**
  - **第一步：p-> Prior-> next = P-> next；（A 的后继指向 C）**
  - **第二步：P-> next-> Prior = P-> Prior；（C 的前驱指向 A）【从左到右写】**
  - 第三步：free(P);    
    - 理解图：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411221538104.png" alt="image-20241122153808990" style="zoom: 60%;" /> p 默认指向 B

2. 设指针变量 P，指向单链表结点 A，指针变量 S，指向被插入结点 A 后面的结点，则操作为：<span style="color:#FF0000;">s--> next = p--> next</span>、P-> next = S;   （单链表没有前驱只有后继）

3. **:warning::star:双向链表交换结点：**

   - ![image-20241201125553257](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202412011255333.png)P指向B，Q指向C，交换BC

   - **核心**
     - **让B后继指针指向D，让D的前驱指针指向B，让A的后继指针指向C，让C的前驱指针指向A，然后C和A再相互链接（C的后继指向B，B的前驱指向C）**

     - **p->next=q->next      q->next->prior=p            p->prior->next=q           q->prior=p-prior             q->next=p                  p-prior=q**

4. **设指针变量 p 指向双向链装中结点 A，指针变量 q 指向被<span style="color:#FF0000;">插入</span>结点 B，要求给出在结点 A 的后面插入结点 B 的操作序列(设双向链装中结点的两个指针域分别为 left 和 right)：**

   - **核心：**
     - **让B的前驱指针指向A ， 让B的后继指针指向C， 让C的前驱指针指向B， 让A的后继指针指向B**    （**先让新插入的结点分别指向A和C，再更新A和C的指向**）

     - **q->left=p                        q-right=p->right              p->right->left=q             p->next=q**

   - **若题目中是删除结点 B，则分为两步：**
   - **核心：**
     - **让A的后继指针指向C，让C的前驱指针指向A**
     - **p->right=q->right            q-right->left=p**

   

4. :star:**常见链表**
   - **单循环链表：单循环链表和普通单链表的区别在于，最后一个结点的 `next` 指针指向头结点，从而使得链表形成一个环。**
      - 但是，**<span style="color:#FF0000;">插入尾结点仍然需要遍历整个链表</span>，时间复杂度为 O(n)**，因为需要找到末尾结点。

   - **带尾指针的单循环链表：带尾指针的单循环链表可以直接访问尾结点，无需遍历整个链表--------------尾指针可以直接访问尾结点 不用经过遍历**
   - **<span style="color:#FF0000;">带头结点的双循环链表</span>：带头结点的双循环链表是双向链表，并且头结点和尾结点都指向循环结构中的相邻结点。**
      - **插入尾元素时，直接访问尾结点指针并插入，不需要遍历，时间复杂度为O（1）**
      - **删除尾结点：直接访问尾结点指针进行删除，不需要遍历，时间复杂度为O（1）**
      - **但带头结点的双向循环链表比带尾指针的单循环链表灵活性更高，因此更推荐使用带头结点的双向循环链表**



## 栈和队列

- :star::warning:**n个不同的元素入栈，可能的出栈顺序有<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411281320335.png" alt="image-20241128132000208" style="zoom: 80%;" />** **---------（卡特兰数）**
- :star:**栈的应用：括号匹配、表达式求值、递归、二叉树的遍历、<span style="color:#FF0000;">图的深度优先搜索</span>**
  - **队列的应用：在计算机系统中的应用、树的层序遍历、<span style="color:#FF0000;">图的广度优先搜索</span>**
  - **:star:其中：图的深度优先搜索是类似树的先序遍历，是栈的应用，广度优先搜索是类似于二叉树的层序遍历，是队列的应用**

- **前后缀表达式求值 （前缀：从后往前入栈，后入栈放前面进行运算 ，后缀：从前往后入栈，先入栈放前面进行运算）**
- **:star:<span style="color:#FF0000;"> 仅在表尾进行插入和删除操作的线性表称为栈 </span>，修改原则为后进先出**
  - <span style="color:#FF0000;"> **队列是表头删除，表尾插入** </span>


### 循环队列

**:star:若题设中具有 MAXSIZE 个单元顺序循环队列，则可用单元为 MAXSIZE-1 个**

- **具有 n 个单元的循环队列，队满时共有 n-1 个元素**
  - <span style="color:#FF0000;"> **若题目中没说明 rear 和 front 的时候，可用单元和队满元素个数均为 n-1 或 MAXSIZE-1** </span>

**循环队列 front 为队头指针，rear 为队尾指针，采用数组 elem [n] 作为存储空间：**

- **队列长度（队伍元素个数）：<span style="color:#FF0000;">（rear+n-front）%n </span>**
- **队满条件：<span style="color:#FF0000;">（rear+1）%n == front </span> **
- **队空条件：<span style="color:#FF0000;"> rear == front </span> **
- **循环队列中插入或删除元素时；操作：<span style="color:#FF0000;">在尾结点后插入，在首结点处删除（尾插首删）</span> ，即rear每插入一结点指针+1，front每删除一结点指针-1（尾插+1，首删-1，互不干涉）**
- 
  - **删除（出队）：**
    - <span style="color:#FF0000;"> **front =(front+1)% QUEUEMAX** </span>
    - **删除操作不改变 `rear` 的位置。**
  - **插入（入队）：**
    - <span style="color:#FF0000;"> **rear =(rear+1)% QUEUEMAX** </span>
    - **插入操作不改变 `front` 的位置。**

## 数组与广义表

- **对称矩阵压缩（一般为下三角矩阵压缩）存储成数组，则数组长度为 n(n+1)/2，下三角矩阵元素为 n²**
  - **若为上三角矩阵压缩**，如题所示（19 年）：
    - <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231647527.png" alt="image-20241123164707458" style="zoom:60%;" />
    - 答案：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231648558.png" alt="image-20241123164804502" style="zoom:60%;" />
      - **带权有向图，且没有提到自环的存在。因此，<span style="color:#FF0000;">所有的顶点 i 到自身 i 的权值默认为 0</span>。**
- **广义表的长度可以通过转换成树，其深度为其树中 o 结点的所在的 <span style="color:#FF0000;"> 最大层数 </span> 或者通过数出最深嵌套层的括号数**
- **稀疏矩阵通常使用三元组和十字链表法，稀疏矩阵压缩后会失去随机存取的特性**-
- :star:**<span style="color:#FF0000;">三元组存储稀疏矩阵</span>所需字节数：设有 n 个非零元素则所需字符数为 <span style="color:#FF0000;">`(n+1)*3*每个元素所占字节数`（+1是因为表头也占字符）</span>**

### **需记公式（均从0开始）**

#### 二维数组的存储`m*n`

##### 行优先

- <span style="font-size:1.2em;">**下标从0开始：`loc(aij) = loc(a0,0)+[i*n+j]*d` -----行优先和总列数n相关**</span>
- <span style="font-size:1.2em;">**下标不从0开始：`loc(aj) = loc(c1,c2)+[(i-c1)*(d2-c2+1)+(j-c2)]*d`**</span>

##### 列优先

- <span style="font-size:1.1em;">**下标从0开始：`loc(aij) = loc(a0,0)+[j*m+i]*d`-------  列优先和总行数m相关**</span>
- <span style="font-size:1.1em;">**下标不从0开始：`loc(aj) = loc(c1,c2)+[(j-c2)*(d1-c1+1)+(i-c1)]*d`**</span>

#### **三维数组存储**

:star::warning:<span style="font-size:1.1em;">**<span style="font-size:1.1em;">对于三维数组`m*n*z`，以行为主序，`a[i][j][k]`地址计算：`loc(a[i][j][k])=loc(a000)+[(i*n*z)+j*z+k]*d`</span>**</span>

:warning: **如果数组不从0开始 `loc(a[i][j][k]) = loc(a[b,c,d]) + [(i - b)*n*z + (j - c)*z + (k - d)] * d `------i,j,k减去对应的首地址**

**注意：**

**若矩阵下标从1开始，则`i和j减1`，若压缩后的一维数组从1开始，则算出来的`k再加1`**



#### 三角矩阵的压缩存储（三角矩阵是对称矩阵的一种）

- **三角矩阵均为n阶方阵**
- 按行序存储，`a[i][j]与s[k]的对应方式`：

$$
\pmb{下三角： k=i(i+1)/2+j}  \\
上三角：k=n(n+1)/2\\
\pmb{计算地址：loc(aij) = loc(a0,0)+[i(i+1)/2+j]*d}
$$

<span style="font-size:1.2em;">	**对于<span style="color:#FF0000;">对称矩阵（i=j）的下三角公式也按此存储方法</span>，即：`a[i][i]=i(i+1)/2 +i=i(i+3)/2`**</span>

​	**注：若矩阵下标从1开始，则`i和j减1`，若压缩后的一维数组从1开始，则算出来的`k再加1`**

![image-20241125191047920](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411251910036.png)

#### 对角矩阵的压缩存储

**非零元素分布在主对角线上和其他对角线上，其余元素为0**

**地址计算：**

- **m对角矩阵，其`m=2b+1`，m为所有对角线的条数，b为主对角上面或下面对角线的条数**

- 用**一维数组**存储，<span style="font-size:1.2em; font-weight:bold; color:#FF0000;">`k=i(2b+1)+j-i=im+j-i`（下标均从0开始）</span>
- - <span style="color:#FF0000;">**<span style="font-size:1.1em;">地址计算：`loc(aij) = loc(a0,0)+[i(2b+1)+j-i]*d`</span>**</span>
    - **注：若矩阵下标均从1开始，则`i和j减1`，若压缩后的一维数组从1开始，则算出来的`k再加1`**

## 串

- **主串长度为 n，子串长度为 m，则简单模式匹配的最坏时间复杂度为 O（nm）, KMP 算法时间复杂度为 O（n+m）**
- <span style="color:#FF0000;">**串既可以链式存储也可以顺序存储**</span>
- **串是字符的有限序列，空串是不包含任何字符组成的串，由空格组成的串是空格串**
- **:star:串中字符均不相同，由n个字符组成的串，其含子串`n(n+1)/2 +1`**
- **串的特殊性在于：数据元素是一个字符【这里数据元素是指串中每一个元素，其每个元素都是由字符组成】**

### :warning: kmp算法

- **next数组：**

  - **下标前两位默认从-1，0开始，看重复字符串的数量（重复是指：最前面n位和最后面n位【最后面元素必须到最右头，且方向始终是从左往右看】，e.g. aba重复数为1，abab重复数为2，ababa重复数为3，ababaa重复数为1）**

- **nextval数组：**

  - **下标前两位默认从-1，0开始，从第三位开始看next数组的下标所对应原始元素，如果相同则将next数组对应的原始元素的nextval取过来，如果不相同，则取当前元素的next数组为该元素的nextval值。**

  <span style="font-size:0.9em; font-weight:bold;">注：如果题目中要从0开始，则所有数组+1</span>
  
  ![image-20241128182006175](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411281820235.png)

## 树与二叉树

- **:star:树中结点数为<span style="color:#FF0000;">所有度数之和（度数 *度的个数）+1</span>**

- <span style="text-decoration:line-through;">**度为m的结点树第i层共有`m^(i-1)`**个</span>

- **高度为 n 的满二叉树，其结点总数为` 2^n -1`**

- **深度为k的完全二叉树，最少结点数：`2^(k-1)`，最多结点数：`2^k -1`------最多结点数即对应满二叉树**

- **二叉树总结点数目最少为（只有度为0和度为2情况，不含度为1的情况）：n0+n2，（n0=n2+1）【注：n2已经包含了根节点】**

- :star:<span style="color:#FF0000;">**高度为n的平衡二叉树至少有`f(n) = f(n-1) + f(n-2) +1`,(n>=3)，其中：`f(1) = 1;f(2) = 2;f(3)=4;f(4)=7`**</span>

- **完全二叉树边号为 i 的结点的双亲结点为：`i/2（向下取整）`**
  
  - **若编号为 i 的结点有左孩子，则左孩子结点为 2i，若编号为 i 的结点有右孩子，则右孩子结点的编号为 2i+1**
  
- **:star:完全二叉树深度：<span style="color:#FF0000;"> `┗log2n┛+1  或 ┏log2(n+1)┓`</span>**

- :star:**哈夫曼树带权路径长度（wpl）为结点值<span style="color:#FF0000;">乘以树的边数（即层数-1）</span>**

- **:star:哈夫曼树中叶子结点有 n 个<span style="color:#FF0000;">，则哈夫曼总共有 2n-1 个结点即有2(2n-1)个链域</span>，若转为二叉链表存储时，有效链域为 2n-2 个（总结点数-1），空链域为 2n 个（总链域-有效链域）**

  - **二叉树有n个结点，则有效链域为n-1，空链域为2n-(n-1)为n+1**
  - **非常规计算题**：
    - **计算等长编码位数，满足`2^t>=n`，t为等长编码位数**
    - **非等长编码即为哈夫曼编码，变长编码平均长度为：∑编码出现频率*变长编码的位数**
    - 计算哈夫曼的**压缩率**：用<span style="font-size:1.2em;">**`等长编码的位数- 变长编码的位数平均长度 / 等长编码的位数`**</span>

- **:star::star:<span style="color:#FF0000;">判断是否是前缀编码</span>：**

  - <u> **在编码方案中，任何一个编码都不是其他任何编码的前缀，即一个编码不能以另一个编码作为开头或者完全一样。（例：110 和 1100，1100 包含了 110，即不是前缀比编码）**

- **先序森林等同于先序遍历二叉树，先序树等先序二叉树----先序都一样**

  - **后序森林等于中序二叉树 ，后序树等于中序二叉树，后序树等于中序森林-----后序都转化为二叉树中序**

- **:star:<span style="color:#FF0000;">二叉排序树中序是递增的</span>，且二叉排序树关键字比较次数：<span style="color:#FF0000;">最好情况下是 O(log n)，最坏情况下是 O(n)</span>（最大值为n）**

  - **二叉排序树的三种情况**
    - **若是删除叶子结点则直接进行删除**
    - **若删除结点有右子树就用右子树的值来进行替换，左子树同理**
    - **<span style="color:#FF0000;">若删除结点有左右子树，则用其右边靠近该结点的第一个中序元素来进行替换</span>。**
  - :star:**二叉排序树的ASL：**
    - <span style="color:#FF0000;">**成功：`每层结点数 * 所在该层的层数 / 结点个数`**</span>
    - **失败：`每层补齐的个数 * 往上的结点数（不含自身）/总补齐的个数`**

- **线索二叉链表树：<span style="color:#FF0000;">有孩子结点为 1，线索（无子结点）为 0</span>，缺左子树指向中序前一个，缺右子树指向中序后一个<span style="color:#FF0000;">（左前右后）</span>**

- :warning:**高度为 h 的 m 叉树的至多有`(m^h-1)/(m-1)`个结点----->一般给出树的总结点数量用此公式求m叉树的高度**

- :warning:**n个结点的二叉树共有：`(2n)!/n!(n+1)!`个形态------------------类比栈的卡特兰数**

- **:star:树二叉树森林转化：**

  - **树转二叉树：1、将兄弟结点加线 ；2、给除左结点外的结点去线；3、<span style="color:#FF0000;">由兄弟转化的结点都是该结点的右结点</span>**
  - **二叉树转树：1、将所有结点其的右孩子连线；2、去除所有兄弟间的连线；3、层次调整；（从上至下，依次加线，依次去线）**
  - **森林转二叉树：<span style="color:#FF0000;">1、将森林中的每棵树都转化成二叉树；2、将第二棵树的根节点作为第一棵树的右孩子，第三棵树作为第二棵树的右孩子，依次类推。</span>**
  - **二叉树转森林：1、从上到下将所有右孩子去线；2、将分离的二叉树转化为树**

  **树转二叉树转森林示意图**

  <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411291229370.gif" alt="2579098-20211126233202207-1856636576" style="zoom: 67%;" />

### :warning: n阶B树（B+树）相关知识点

- **关键字数量**：

  - **每个节点最多含有 n−1个关键字。**

  - 
    $$
    \pmb{每个节点至少含有 \lceil \frac{n}{2} \rceil - 1个关键字，除非这个节点是根节点。}   【向上取整】
    $$

- **子节点数量**：

  - **每个节点最多可以有 n 个子节点。**

  - $$
    \pmb{每个节点至少有 \lceil \frac{n}{2} \rceil 个子节点，除非这个节点是根节点。}  【向上取整】
    $$

  
  **子节点数量>关键字数量**
  
  B+树是B树的升级版本，核心就是使查询速度更快，主要用于数据库的索引，e.g.MySQL数据库，**B树、B+树的时间复杂度为O(log n)**

## **图**

- **完全无向图共有` n(n-1)/2` 条边，完全有向图有 `n(n-1)`条边。----这里n为顶点数量**
  - **若题目中给出为<span style="color:#FF0000;">非连通无向图</span>，则<span style="color:#FF0000;">顶点数量由边数和上述公式得出后，需要额外+1</span>**

  - **:warning:e.g.：若G非连通无向图共有28条边，则该图至少与多少个顶点----------根据`n(n+1)/2`得出n为8，但为非连通则需额外+1，顶点数至少为9-**
    - **也可根据非连通图最大边树(n-1)(n-2)/2 = 28得出n为9**
  
- **:star:无向图 n 个顶点，要使得无向图为<span style="color:#FF0000;">连通图，则至少为` n-1 `条边</span>，若是无向图为非连通图则最多可能有 `(n-1)(n-2)/2`边--根据此公式知总边树可计算非连通图的顶点数** 
  - <span style="color:#FF0000;">**若连通图包含 n 个顶点，则对应的生成树为 `n-1` 条边**</span>
    - **如果有一个有向图有N个顶点，<span style="color:#FF0000;">如果是强连通图，那么至少需要n 条边（和顶点数量相等，形成回路）</span>， 如果这个强连通图是一个环，那么<span style="color:#FF0000;">它有 n 棵生成树。</span>**
- **无向图邻接表有 m 个边表结点（非零元素个数，为边数的二倍），则无向图边的数为 m/2**-----------**有向图：边等于边表结点数目**
  - **无向图邻接矩阵零元素个数为 n²-2e**

  - **有向图邻接矩阵元素个数为 n²-e**
- <span style="color:#FF0000;">**一个图的邻接矩阵表示法是唯一，邻接表不唯一**</span>
- <span style="color:#FF0000;">**在图中所有顶点度数之等于所有边数的 2 倍**</span>
- **:warning: 某图有n个顶点，e条边，采用邻接矩阵表示图，拓扑排序算法的时间复杂度为O(n+e)**

**复盘：**

- 完全无向图：n(n-1)/2，完全有向图：n(n-1)
- 连通图：至少n-1条边------连通图生成树：n-1边，非连通图最多：(n-1)(n-2)/2边；
- 强连通图：n条边（和顶点数量相等）------n棵生成树
- 无向图邻接表：2n（边数二倍），有向图邻接表（和边相等） ------
- 零元素个数：无向图：n^2-2e；有向图：n^2-e

### 经典例题：

1. **一个无向图中有40条边，度为5的顶点有6个，度为4的顶点有4个，其余顶点度均小于4，则该图最少的顶点数为。**
   - :star::star:**在图中所有顶点度数之等于所有边数的 2 倍，则总度数和为`40*2=80`，已知度数之和为`6*5 + 4*4=46`，剩余度数为`80-46=34`，为使得图中顶点最少则尽量使用度数为3的顶点，故`┏34/3┓=12`，综上，总度数为`6+4+12=22`**

### 最短路径？？？？？？？？？

- #### 迪杰斯特拉算法

- #### Floyd 算法？？？？？？

### 关键路径 ？？？？？？？

## 查找

### 复盘总结

#### **时间复杂度：**

- **顺序查找：O(n)**

- **折半查找：O(log₂n)-----最坏是O(n)**
- **分块查找：O(log₂n+n)**
- **散列查找： O(1)，平均查找长度与结点个数 n 无关**
- **二叉排序树查找O(log₂n)**

**总结：散列查找与n无关，时间复杂度最大的是分块查找，其次是顺序查找，最小的是折半查找与二叉排序树查找**

#### **是否有序**

- **顺序查找：适合无序查找**
- **折半查找：需要有序**
  - **进行折半查找要求该表以顺序方式存储，且结点按关键字有序排列**
- **分块查找：可以无序，适合结点动态变化情况**
- **散列查找、二叉排序树查找：无序**

#### **平均查找长度**

- **顺序查找ASL：`(n+1)/2`**
- **折半查找ASL：一般用判定树来进行计算**
  - **成功：`每层结点数 * 所在该层的层数 / 结点个数`**
  - **失败：`每层补齐的个数 * 往上的结点数（不含自身）/总补齐的个数`**
    - :star:'**查找次数：为判定树高度=h = `  ┗ log₂n ┛  + 1 `或者 h = `┏ log₂(n+1) ┓`**
- :warning:**分块查找ASL：长度为n，子表数量为k，n/k为子表长度--->`(k+n/k) / 2 +1`**
- **二叉排序树查找ASL：同折半查找**
- **散列查找ASL：用哈希函数计算**

#### :warning: 顺序查找和线性表区别

- **顺序查找第i个元素（查找成功）需要比较n-i+1次，查找失败比较次数为n+1次**
- **线性表插入元素，平均移动：n/2次，需要移动：n-i+1次（同顺序查找查找成功比较次数一样）；**
  - **删除元素：平均移动：(n-1)/2次，需移动：n-i次**

### 顺序查找

顺序查找适合于顺序表和链表，<span style="color:#FF0000;">**通常用于无序查找**，**从后往前开始**</span>

- **找第 i 个元素需要<span style="color:#FF0000;">比较的次数：n-i+1</span>**
- **如果要找的不在表中则比较次数为<span style="color:#FF0000;">（查找失败）：n+1</span>**
- **长度为 n 的顺序表，查找任一元素<span style="color:#FF0000;">平均查找长度为(ASL)：(n+1)/2</span>**
- **时间复杂度：0(n)**

**优缺点：适用范围大，元素无次序  ，当 n 较大时效率较低**

 **注意：**

- **单链表和顺序表实现时间复杂度都为 O(n)，但**
  - **删除第一个元素时，单链表可直接删除不需要移动元素，而顺序表删完后需要移动元素，所需时间更多，故此情况下单链表时间快**
  - **若在最后一个元素插入一个新的元素，单链表需要遍历到最后一个元素才能进行插入，而顺序表仅需根据下标即可，不需要移动元素，即顺序表速度大于单链表速度**
  - **若交换两个元素，单链表均需要遍历到该元素位置才能完成交换，而顺序表无需遍历，仅根据下标即可完成，故顺序表速度快**
  - **总结**：
    - **删除首元素和在首元素之前插入，选链表**
    - **在最后元素插入、删除或交换两个元素，选顺序表**
    - **总而言之，对于整体而言，链表适合插入和删除、顺序表适合查找**


### 折半查找 （二分查找） ┗   ┛   ┏    ┓

**<span style="color:#FF0000;">适用于有序查找</span> ，<span style="color:#FF0000;">时间复杂度为 O（log₂n）</span>**

对 **顺序表进行折半查找** 时，该表必须以 **顺序方式存储，且结点按关键字有序排序**

**【注：二分查找（折半查找）查找成功的平均查找长度，用判定树来进行计算，查找成功长度为（每层结点个数 * 树的层数）/结点个数】**

-  **确定中间位置为mid = ┗  (low+high)  / 2 ┛（向下取整）**
- **若中间位置等于待查数字之 4 则查找成功，若中间位置值小于待查数字值，则 low = mid + 1    若中间位置值大于待查数字值，则 high = mid - 1**

**优缺点：比较次数少，查找速度相对快，查找前需要建立有序表，适用范围少，并不是一定比顺序查找速度快**

#### 折半查找的ASL

**和二叉排序树的ASL一样**

- **成功：`每层结点数 * 所在该层的层数 / 结点个数`**
- **失败：`每层补齐的个数 * 往上的结点数（不含自身）/总补齐的个数`**

#### 折半查找判定树

**折半查找判定树是一颗平衡二叉树，其核心思想同<span style="color:#FF0000;">二叉排序树</span>一致，（核心思想：中间大的放中间，最小的放左子树，最大的放右子树）**

**判定树的高度为：h = `  ┗ log₂n ┛  + 1 `或者 h = `┏ log₂(n+1) ┓`，比较成功时，同关键字比较次数最多为 h，时间复杂度为 O（log₂n）**

例，若有 1000 个元素，则采用**折半查找**则至多比较 **┏ log₂(1000+1) ┓ 次** 数

#### 构建判定树快速法

1. **根据元素数量，画出二叉树，<span style="color:#FF0000;">每次先画右结点的右子树，再画左结点的右子树</span>，当每行所有右子树都画完时，然后<span style="color:#FF0000;">再先画右结点的左子树，再画其他左子树</span>---------------<span style="color:#FF0000;">（均是从右往左）</span>**
2. **画完二叉树，确定根节点元素，然后按照序列的<span style="color:#FF0000;">中序遍历</span>进行填充，和根节点元素进行比对**

**补充：**

- **查找元素需要与哪些元素进行比较时，可按照二叉排序树的插入进行比较，（从根节点开始，若大于根节点则从右子树开始比较，若小于根节点则从左子树开始比较，依次递归，直到查找完成）**
- **其中 ASL 查找成功和失败按照二叉排序树的查找成功失败来进行计算**

### 分块查找（索引查找）

**分块查找又成索引顺序查找，是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此<span style="color:#FF0000;">特别适合结点动态变化的情况</span>**

- **原始序列可以无序，将其进行分块，不一定要进行等分，选择每个块中最大的元素放入一张索引表，并记录该元素的地址，索引表内元素需有序**

- :stars:**若表长度为 n，子表数量为k，且每个子表的长度相等为`s=n/k`，则进行成功查找的平均查找长度为：`(k+n/k) / 2 +1`**

### 二叉排序树查找

- <span style="color:#FF0000;">**n 个结点的二叉排序树，平均情况时间复杂度为 O（log₂n）, 最坏情况下为 O(n)**</span>
- **二叉排序树的进行中序遍历，得到的结点序列一定是个有序序列**

### 散列查找

- **哈希函数构造方法：假定散列表长度为M，取一个不大于M但最接近或等于M的质数（只有1和它本身整除）P**
- **平均查找长度与结点个数 n 无关**

**相关计算公式：**

- **装填因子=表中记录树/散列表长度**

## 排序

### 复盘总结

#### 选择什么排序

- **数据量大（n 较大）且需挑选前十个最大元素：----------堆排序**
- **数据量大（n 较大），关键字位数少且可分解-------------基数排序**
- **数据量小（n 较小）-----------------------------------------------直接插入排序或简单选择排序**。
- :star:**数据基本有序--------------------------------------------------------直接插入排序或冒泡排序**
- **需要稳定性且时间复杂度为O(nlogn)------------------------归并排序**
- **数据量大且时间复杂度要求为O(nlogn)---------------------快速排序、堆排序或归并排序**------快速排序随机分布情况下平均时间复杂度最短，但不稳定；堆排序和归并排序性能稳定。
- **数据量大且关键字随机，无需稳定性-------------------------快速排序**

- ------

  **基数排序不是基于比较的排序算法**

- **对于堆排序和快速排序，若原始序列接近有序，则选堆排序**	
  - :star:**对于接近有序的序列：速度从快到慢排序：直接插入排序-->冒泡排序--->堆排序-->选择排序-->快速排序**
  - **:star:在堆排序中，关键字降序选择大根堆，升序选择小根堆。**

- **不稳定排序：“快些选一堆好友来聊天”--------（快速 希尔 选择 堆）**

- **平均复杂时间复杂度快：”快些归队"-----（快速 希尔 归并 堆）**

- **每趟至少确定一个元素位置：“快选一堆帽子”------（快速 选择 堆 冒泡）**

#### 与序列有无关

- **与初始序列无关**
  - **移动次数无关："基数排"-----（基数排序）**
  - **比较次数无关：”选堆归折”-------（选择 堆 归并 折半排序）**
  - **时间复杂度无关：”选堆归基“-----（选择 堆 归并 基数排序）**
  - **排序趟数无关：”选插归基“----（选择 插入 归并 基数排序）**
- **与初始序列有关**
  - :star:**冒泡和快速排序----易受初始序列影响**

#### 时间复杂度

- **堆排序：全部情况均为O(nlog2n)**

- **归并排序：全部情况均为O(nlog2n)**

- **快速排序：平均和最好都是O(nlog2n)，最坏是O(n^2)**

- ------

- **希尔排序：平均为O(n^1.3)**

- ------

-  **简单选择排序：全部情况均为O(n^2)**


- **冒泡和直接插入排序：最好情况为O(n)，平均和最坏是O(n^2)**

  - :star:**对于冒泡排序：在有序时性能极佳为O(n)，逆序时最坏为O(n^2)**

**平均时间复杂度大小关系：快速、堆、归并排序 > 希尔 > 选择、插入、冒泡排序**

#### 空间复杂度

- **O(1)------即需要一个辅助单元**
  - **堆排序、直接插入排序、冒泡排序、选择排序、希尔排序**
- **O(log2n)**
  - **快速排序（最好）**
- **O(n)**
  - **快速排序：（最坏）**
  - **归并排序**

**堆排序（插入、冒泡、选择、希尔）< 快速排序 < 归并排序**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411291501735.png" alt="image-20241126152839361" style="zoom:67%;" />

#### **比较次数**

- **简单选择排序：比较次数固定始终为n(n-1)/2，交换次数固定为n-1次**
- **m路归并排序：每选出一个元素需要比较m-1次**
- **冒泡排序：最少的比较次数为n-1次----即在有序情况下，最坏的情况：n(n-1)/2**
- **直接插入排序：最少的比较次数为n-1次----即在升序排列情况下，最坏的情况：n(n-1)/2-------即在降序排列情况**
