# 操作系统小题

## 填空

### 第一章 概论

- 计算机系统是由硬件系统和软件系统。
- 操作系统的基本类型主要有批处理操作系统 、分时操作系统和实时操作系统。
- 多道程序设计技术能充分发挥 CPU 与外设并行工作的能力，多道程序设计特点：多道、宏观上并行、微观上串行。
- 程序并发执行与顺序执行相比多了些新的特征：分别是：并发、共享、不确定性（不可再现性、异步性）
- **并发和共享是操作系统两个最基本的特征**
- 操作系统中不可中断执行的操作称为：原语
- 分时操作系统主要特征：及时性、交互性、独立性。分时操作系统是在用户态下执行。**分时操作系统追求的目标是比较快速响应用户。**
- 实时操作系统两个基本特征：**及时性和高可靠性**
- 批处理操作系统不允许用户随时干预自己程序的运行

### 第二章 进程管理

- 进程的三种基本状态：运行、阻塞、就绪

- 多个程序同时装入一个计算机系统的主存中并行执行，这个程序设计技术称为：多道程序设计

- 进程由程序段、数据段、进程控制块（PCB）组成的。其中进程控制块是保存进程状态、控制进程转换的标志，也是进程存在的唯一标志。进程控制块的初始化工作包括：初始化标识符信息、初始化处理及状态信息、初始化处理机控制信息。

- 引入线程前：进程是资源分配、调度和管理的最小单位。若引入线程后：进程是拥有资源基本单位、线程是独立调度基本单位。

- 进程的基本特征：动态、并发 独立、异步、结构特征。

- 若有五个用户进程，则处于就绪状态下进程最多有五个，最少有 0 个。若处于用户态（即某用户程序正在运行）则处于就绪状态下的用户进程最多有四个，最少有 0 个。

- 进程调度解决的是把 cpu 如何有效分配给进程

- 系统中各进程之间的逻辑上的相互制约关系称为同步。互斥是指进程间在使用共享资源方面的约束关系

- 临界资源的概念是一次仅允许一个进程访问资源，而临界区是指进程中访问临界资源的那段程序代码。

- **当前信号量若大于 0** 表示：**可用资源数目**。**信号量小于 0** 的**绝对值为请求资源被阻塞进程的数目**。:star:

- 任何一个进程进入临界区之前调用 wait 操作，退出临界区应调用 signal 操作

- **有 m 个进程共享同一临界资源**，若 **使用信号量机制实现对资源的互斥访问**，**信号量值的变化范围：【-m+1，1】**

- 操作系统中，对信号量 s 的 wait 原语操作定义中，使进程进入相应等待队列的等待的条件：s < 0

- 当系统采用**资源有效分配**方法**预防死锁**，它破坏了产生死锁的必要条件中的**循环等待条件**

- **在有 m 个进程的系统中出现死锁**，**死锁进程的个数 k 应该满足的条件为：2 <= k <= m**（**至少需要两个进程互相等待**才能形成循环等待【死锁】）

- 一个计算机系统有 6 台打印机，N 个进程争夺使用，每台进程要求 2 台，系统不会发生死锁，则 N 应该满足：N < 6

  - $$
    1、n 个进程都需要 k 个资源，至少需要 n(k-1)+1 个资源才不会发生死锁，发生死锁的最大个数为：n(k-1)\\
    2、系统可用资源数为 k，进程数为 N，每个进程最大请求数为 m，只有当 k > N(m-1)不会发生死锁，\\此时 N 满足 N < k/(m-1)  (N <= k(m-1)-1)。当 k = N(m-1)会发生思索，此时 k 为最大值。\\
    3、S 台同类设备，N 个并发进程分别需要 a, b, c...台设备，则不会发生死锁的 k 的最小值为：(a-1)+(b-1)+(c-1)...
    $$

- **（1）预防死锁：四个破坏条件**。**（2）避免死锁：银行家算法。 （3）死锁检测的检测与解除：资源分配图化简法**。

- 死锁产生的四个条件：互斥条件（无法破坏）、不剥夺条件、请求并保持条件、循环等待条件。

- **产生死锁的根本原因：系统资源分配不足和进程推进顺序非法**

### 第三章 处理机调度

- 进程调度方式分为：抢占式和非抢占式。
- 截止时间的保证是选择实时调度算法的重要准则，平均周转时间短是批处理系统中选择作业调度算法的重要准则。
- 先来先调度算法只能采用非抢占式调度方式。时间片轮转只能采用抢占调度方式。
- 动态优先权时，随着 **进程执行时间的增加**，其优先权降低
- 平均周转时间最短的调度算法是短进程调度算法。
- 会导致饥饿现象的算法为：短作业优先调度算法、优先级调度算法。
- 先来先调度算法对长作业有利，对短作业不利
- **有利于 CPU 繁忙型的作业，而不利于 I/O 繁忙型的作业是先来先调度算法。**

### 第四章 存储器管理

- 采用请求分页式的存储管理系统，地址变换过程中可能会因为越界、缺页、访问权限错误等原因而产生中断
- 存储管理实现的功能为：主存空间的分配与保护、主存空间的地址重定位、主存的共享和主存的扩充。
- 分区分配算法中 **首次适应算法** 倾向于优先利用内存中的 **中低地址部分空闲分区**（按起始地址递增），从而保留高地址部分的大空闲区。
- 动态重定位是在目标程序执行的过程在 CPU 访问内存之前，由 **硬件地址映射机构或重定位寄存器** 来完成指令或数据的相对地址转换为物理地址的过程。
- 动态重定位是在程序执行时进行重定位，静态重定位是在装入内存时进行重定位
- 分页存储管理把主存储器分成大小相等的许多存储块，与此对应，程序的逻辑地址也分成大小相同的页，页的大小与块的大小相等。
- 段式存储管理必须为每个作业建立一张段表，且对每一段对应有一张页表。
- 整体对换技术通常以进程为基本单位。
- 将用户源程序变为可在内存中执行的程序通常需要：**编译、链接、装入** 三个步骤，其中 **链接** 分为 **静态链接、动态链接、运行动态链接**；**装入** 分为：**绝对装入、可重定位装入、动态运行装入。**
- **可重入程序** 是通过 **减少对换数量** 来改善系统性能的。
- 采用段页式存储管理时，内存地址结构是二维的，存储管理方式中提供一维地址结构的是分页存储管理。
- 在内外部碎片中，只有 **分段式存储管理** 会产生 **外部碎片**，其余 **分页式存储管理、固定分区式存储管理、段页式存储管理** 方式会产生 **内部碎片**。
- **在页表存储管理中，页表的起始地址一般存放在 页表寄存器 中。**
- 页表的作用是实现页号到物理块号的地址映射。
- 具有对换功能的OS，把外存分为文件区和对换区。其中**主要目标是提高进程换入换出速度的是对换区**，采用的是**连续分配**方式。
- **请求分页存储管理**：分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。
- 请求分页系统中每个页表包含：**页号、物理块号、状态位P、访问字段A、修改位M和外存地址**。
- **请求分页存储管理**中，**若把页面尺寸增加一倍，在程序顺序执行时，则一般缺页中断次数为减少**。
- 关于**缓冲技术**中是**以空间换取时间的技术**
- 可重定位分区分配的碎片是内存中容量小、无法利用的小分区
- **虚拟存储器**的**基本特征**是：**多次性、对换性、虚拟性**
- **虚拟存储器**受到的**限制**有**外存的容量和指令中表示地址的字长**，虚拟存储管理策略可以**扩大逻辑内存容量**。
- **具有虚拟存储功能的管理方法是请求分页存储管理。**
- 页面置换中，**频繁的页面调度行为称为抖动**。

### 第五章 设备管理与文件管理

- 常用设备分配技术：独占分配、共享分配、虚拟分配；I/O 设备可分为 **独占、共享 、虚拟** 
- 设备分配程序在**分配外部设备**时，**先分配设备 ，再分配设备控制器 ，最后分配通道**
- 设备管理中引入**缓冲机制**的主要原因是为了：**缓和cpu和I/O设备速度不匹配的矛盾**、**减少对cpu的中断频率和放宽对cpu响应时间限制**、**提高CPU和I/O设备并行性**
- 磁盘访问时间由三部分时间组成：**寻道时间、 旋转延迟、及数据块的传输时间**。
- 磁盘与主机之间传递数据是以**数据块**为单位
- 磁盘空间管理方法：**空闲表法、空闲链表法、位示图法和成组连接法**
- 利用 **SPOOLING 技术**可以将 **独占设备改造成可共享的虚拟设备**。
- 实现 **SPOOLING 系统**时必须在磁盘上开辟出称为 **输入井**和 **输出井** 的专门区域，以存放输入输出信息。
- 为**实现 CPU 与外部设备的并行工作**，系统引入了**中断和通道** 硬件机制。
- 常用的 I/O 控制方式有：**程序直接控制方式、中断控制方式、DMA控制方式 和通道控制** 。
- I**/O 控制的主要功能**是**解释用户的 I/O 系统调用、设备驱动 和中断处理**。
- **通道**是指专用于负责**输入／输出工作（I/O）的处理机**，通道所执行的程序称为**通道程序** 。
- 逻辑设备表(LUT)的主要功能是： **逻辑设备名映射为物理设备名**
- 读／写一次磁盘所需的时间可以分解为寻道时间 、旋转延迟时间 和数据传输时间 这三部分。
- **IO软件层次结构**（此顺序为**从上到下**）：**用户层 IO 软件、设备独立性软件、设备驱动程序、中断处理程序**
- **一个设备驱动程序可以驱动一种类型的设备**
- 基本的**物理存储组织**形式有：**连续分配、链接分配(显示链接、隐式链接)、索引分配 **
- 索引文件大体上由 **索引区**和**数据区** 构成；其中**索引区**一般按关键字的顺序存放。
- **操作系统实现按名存取进行检索**的关键在于**解决文件名与 文件存储地址的转换**。
- 每个索引文件都至少有一张**索引表**，其中的**每一个表项应包括能标识该记录的<u>关键字</u>** 和**该记录的存放地址** 
- 每个索引文件都必须有一张**索引表**，其中**每个登记项用来指出一个逻辑记录的<u>首地址</u>**
- 文件系统的主要目的是 **实现对文件的按名存储**
- 顺序结构**不利于文件动态增长**，文件采用**直接存储方式且文件大小固定**，也宜选择**顺序文件结构**



## 简答

### 第一章：略

### 第二章：进程管理

#### **阐述何为死锁及产生的四个条件及解决死锁方法：**

- 死锁**定义**：**由于系统中存在一些不可剥夺资源，当两个或两个以上的进程占有自身的资源并请求资源时，会导致每个进程都无法向前推进，这就是死锁。**

- 死锁产生的**四个条件**：**互斥条件（无法破坏）、不剥夺条件、请求并保持条件、循环等待条件。**

- **解决死锁的方法分为：预防死锁、避免死锁、死锁的检测与解除**

  - **预防死锁**的四个方法：

    - **破坏互斥条件**：某些资源只能被互斥访问，某些情况保护互斥性。（**不可行**）

    - 破坏不剥夺条件：释放已经占用的资源。

    - 破坏请求并保持条件：一次性申请完所需的全部资源。

    - 破坏循环等待条件：采用顺序资源法，进程进行顺序推荐。

  - **避免死锁**：如银行家算法等。

  - **死锁的检测与解除**：如资源分配图

### 第三章：处理机调度

#### **何谓静态和动态优先权？确定静态优先权的依据是什么？**

静态优先权和动态优先权是两种 **确定进程或任务在系统中优先级的方式**，用于调度系统中的任务。

静态优先权是指在系统启动或任务创建时，优先级被分配并 **在任务的生命周期内保持不变**。任务的优先级一旦设定，**不会** 根据系统运行时的状态或任务的行为 **进行调整**。

静态优先权通常根据一下几个因素来确定：任务的重要性、任务的周期性、任务的资源需求、任务的响应时间需求来确定；

------

动态优先权是指任务的优先级在其运行过程中可根据系统的状态、任务的行为或其他因素 **进行动态调整**，这种方式更灵活，**能够适应系统** 运行时的 **需求变化**。

动态优先权调整基于一下几个因素：任务的等待时间、任务的剩余执行时间、系统的负载状态、任务的截止时间

#### **比较 FCFS 和 SPF 进程调度算法**

| 比较项目     | FCFS（先来先调度算法） | SPF（最短进程调度算法）          |
| ------------ | ---------------------- | -------------------------------- |
| 调度策略     | 先到先服务，不发生抢占 | 优先短作业，分为抢占式和非抢占式 |
| 平均等待时间 | 较长                   | 较短（理论上最短）               |
| 响应时间     | 较差                   | 较好，系统交互性好               |
| 公平性       | 高，按到达顺序         | 较低，长作业会产生饥饿现象       |
| 实现复杂度   | 简单                   | 较负责，需要知道进程执行时间     |
| 适用场景     | 批处理，负载轻系统     | 任务执行时间已知的场景           |

### 第四章：存储管理

#### **存储管理的主要内容是：**

- **内存的分配与回收、 内存碎片问题及其解决、分页和分段管理、虚拟内存管理、内存保护与安全、内存共享与通信、缓存管理、内存管理**

#### :star:分页式、段式、段页式访问内存次数及其过程

- **在页式存储管理中，访问指令或数据时，首先要访问内存中的页表，查找到指令或数据所在页面对应的页表项，然后根据页表项查找访问指令或数据所在的内存页面。需要访问内存 2 次。<u>若系统中有快表，则在快表命中时，只需要访问内存 1 次</u>。** 

- **段式存储管理同理，需要访问内存 2 次。 <u>若系统中有快表，则在快表命中时，只需要访问内存 1 次。</u>**

- **段页式存储管理，首先要访问内存中的段表，然后访问内存中的页表，最后访问指令或数据所在的内存页面，需要访问内存 3 次。**

- **对于比较复杂的情况，如多级页表，若页表划分为 N 级，则需要访问内存 N+1 次。**

#### **试叙述页式系统的地址变换步骤(带快表)。**

1. 逻辑地址 (p,d) 被分解为页号 p 和页内偏移 d。 
2. 先在快表 (TLB) 中查找页号 p 是否有对应的物理页框号 f。 
3. 如果快表未命中，则访问页表查找页号 p 对应的物理页框号 f。 
4. 将找到的页表项更新到快表中。 
5. 使用页框号 f 和页内偏移 d 生成物理地址 (f,d)(f, d)(f,d)。 
6. 使用生成的物理地址访问物理内存。

**为实现分页式虚拟存储，页表中至少应含有哪些内容?**

- **页表**中至少应包含以下基本内容：**页框号、物理块号、状态位P、访问字段A、修改位M和外村地址**。这些信息共同支持了**分页式虚拟存储系统的地址转换、内存管理和访问控制功能。**

**虚拟存储器的特征是什么?虚拟存储器的容量主要受到哪两方面的限制?**

- 特征：**多次性、对换性、虚拟性**。**虚拟内存受内存和外存容量限制**



### 第五章：设备管理与文件管理

#### 简述文件的逻辑结构和物理结构有哪几种。分析逻辑结构中的索引 结构和物理结构中的所以分配有什么不同。

- **逻辑结构：顺序文件、索引文件、顺序索引文件、直接文件或散列文件 **

- **存储结构（物理结构）：连续分配（顺序）、链接分配(显示链接、隐式链接)、索引分配 **
- **不同：逻辑结构强调的是文件之间的逻辑关系，而存储结构强调的是文件具体在计算机上 是怎样存储的(注意比较索引在逻辑结构和存储结构中的不同)**

#### **IO软件层次结构和各结构作用：**

**（从上到下）用户层 IO 软件、设备独立性软件、设备驱动程序、中断处理程序**

- **用户层IO软件：提供系统调用与库函数**
- **设备独立性软件：为用户提供简单、统一的调用接口**
- **设备驱动程序：设置设备寄存器，检查设备状态**
- **中断处理程序：进行中断处理**

#### 简述中断处理的过程。

- **触发中断**：硬件或软件事件需要 CPU 立即处理时，触发中断信号。
- **保存状态**：CPU 保存当前状态，包括程序计数器（PC）和处理器状态字（PSW）。
- **禁用中断**：暂时禁用其他中断以防干扰。
- **识别源**：检查中断向量表确定中断源。
- **执行处理程序**：跳转到对应的处理程序，执行相关操作。
- **恢复状态**：处理中断后，恢复之前的 CPU 状态。
- **结束中断**：重新启用中断，继续执行被打断的程序。

#### I/O 中引入缓冲的主要原因是什么?

- **解决cpu和I/O设备速度不匹配的矛盾**：由于 CPU 和内存速度远高于 I/O 设备，引入缓冲区可以暂存数据，减少 CPU 等待 I/O 完成的时间。
- **减少 CPU 的 I/O 等待时间**：在大量数据传输时，缓冲区允许一次性传送大数据块，降低多次小数据块传输的开销，从而减少 CPU 的等待时间。
- **减少对cpu的中断频率和放宽对cpu响应时间限制**
- **提高CPU和I/O设备并行性**

#### 在 FAT 文件系统中，文件分配表（FAT）有什么作用？

FAT 文件系统中的文件分配表（FAT）负责跟踪和管理文件在磁盘上的存储位置，支持文件的 连续和非连续存储，管理磁盘空间，导航文件的读写操作，并在文件删除时回收磁盘空间。 FAT 表是 FAT 文件系统的核心组件，确保文件数据能够被有效管理和访问。

#### 12.SPOOLing系统的特点是什么?

- ①提高了1/0的速度，缓和了CPU和低速I/O设备之间的速度不匹配的矛盾;
- ②将独占设备改造为共享设备
- ③实现了虚拟设备功能。



#  操作系统应用题

## 前趋图、伪代码  ？？？？？



## 作业调度七种算法

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231908412.png" alt="image-20241023190820258" style="zoom:67%;" />  

### 先来先服务算法(FCFS)

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231909783.png" alt="image-20241023190959697" style="zoom: 67%;" />  

### 短作业优先算法(SJF)

**注：不同到达时间，<u> 先到达的作业优先执行 </u>，当执行完的时候看其他几个作业是否到达，如果剩下作业都到达按照短作业优先”**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231911235.png" alt="image-20241023191142172" style="zoom: 67%;" />  

#### 非抢占

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231912394.png" alt="image-20241023191214346" style="zoom:67%;" />  

#### 抢占

- **基于最短剩余时间(SRTN)**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231914174.png" alt="image-20241023191413120" style="zoom:67%;" />  

**注：当 D 执行到第八秒的时候，D 还剩 2 秒要小于 E 服务时间 4 秒故还是先执行完 D 再执行 E**  

### 优先级别调度算法

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231921740.png" alt="image-20241023192100671" style="zoom:67%;" />  

### 高响应比调度算法(HRRN)

**响应比 = 1+ 等待时间 / 服务时间**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231924212.png" alt="image-20241023192419032" style="zoom:67%;" />  

<span style="color:#FF0000;"> **注：等待时间为调度时间减去到达时间（单位：分钟），先算出第一次调度优先级，当计算第二次调度作业时第二次调度的开始时间要变为第一次调度开始时间再加上最先调度作业的服务时间**  </span>

**（第二次调度时间开始为 10：40，等待时间 = 开始时间 - 到达时间）**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231934608.png" alt="image-20241023193404502" style="zoom:67%;" />  

### 时间片轮转调度算法（RR）

#### 不同到达时间

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232049804.png" alt="image-20241023204948616" style="zoom: 50%;" />  

**解题思路：当不再加入新任务时，即此时时间来到第四秒结束，此时序列为 BDAEC，后一直按照此序列重复下去，若某一作业当满足服务时间后，去除该作业，其他作业继续重复，直到全部满足。**  

**当 q(时间片)为 4 的时候为最大服务时间则不会执行时间片轮转改为先来先服务算法（FCFS）**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232052592.png" alt="image-20241023205202535" style="zoom: 80%;" />  

#### 相同到达时间

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232300936.png" alt="image-20241023230054832" style="zoom:67%;" />  

**解题思路：相同到达时间即一直重复 ABCDE，若某一作业当满足服务时间后，去除该作业，其他作业继续重复，直到全部满足**  

![image-20241023230136540](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232301599.png)  

**当 q(时间片)为 4 的时候为最大服务时间则不会执行时间片轮转改为先来先服务算法（FCFS）**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232306269.png" alt="image-20241023230651200" style="zoom: 80%;" />  

### 最早截止时间算法（EDF）

- 抢占  
  - 【实时调度算法之最早截止时间优先调度算法（抢占）】https://www.bilibili.com/video/BV1zD421n7Rs?vd_source = c8b64e308ba0a6999b868fdf4177d69f  
- 非抢占  
  - 【实时调度算法之最早截止时间优先调度算法（非抢占）】https://www.bilibili.com/video/BV1Tt421E7i3?vd_source = c8b64e308ba0a6999b868fdf4177d69f  

**注：开始执行时间 > 最早截止时间则该任务不能被调度**  



### 最低松弛度优先算法(LLF)

![image-20241026124145950](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261241002.png)  

【实时调度算法之最低松弛度优先算法】https://www.bilibili.com/video/BV17M4m1X7MT?vd_source 

## pv 操作考代码

## :star:银行家算法

【操作系统银行家算法例题讲解】https://www.bilibili.com/video/BV1gK411x7Ra?vd_source 

- **Need 矩阵是怎样的？** 
  - **Need = Max - allocation**
  
- **系统是否处于安全状态？如安全，请给出一个安全序列。** 

  - **work(available) >= need 满足安全**

- **若从进程 P1 发来一个请求(0,4,2,0)，这个请求能否立刻被满足？如安全，请给出一个安全序列。**
  - **解：p2发出的请求向量Request（），系统按银行家算法进行检查**
    - request 2()<= Need2()

    - request2()<=Available()

  - 系统假定可为p2分配资源，并修改p2 available、allocation、need的值
    - **Available = available - request**
  
    - **Allocation = allocation + request**
  
    - **Need = need - request**
  
  - 此时再进行安全性检查，并判断
    - 存在安全序列
  
    - 由于不存在满足需求的进程，所以系统不可以将资源分配给它。
  


## 动态分区分配算法（连续分配）

- 首次适应  
  - **从头部开始查找，找到第一个能满足大小的空闲分区**  
- 最佳适应  
  - 将空闲分区按容量进行从 **小到大排序，选满足的第一个空闲分区**  
- 最坏适应  
  - 将空闲分区按容量进行 **从大到小排序，选满足的第一个空闲分区**  
- 邻近适应（循环首次适应）  
  - 从上次查找结束的位置开始检索  
  - 算法开销小，但会使高地址的大分区被用完  

### 分区回收

【【操作系统】【考研真题】2017 年第 25 题【动态分区存储管理】分区分配与回收】https://www.bilibili.com/video/BV1Zd4y127Bd?vd_source = c8b64e308ba0a6999b868fdf4177d69f

【「操作系统题目」动态分区分配和回收算法】https://www.bilibili.com/video/BV1Ap4y167A9?vd_source = c8b64e308ba0a6999b868fdf4177d69f

## 基本分页存储管理（非连续分配）

### 逻辑地址、物理地址转换

- 逻辑地址位数可根据逻辑空间大小来计算，**若逻辑空间大小为 2^10B，则逻辑地址位数为 10 位**  

- **用逻辑地址除以页面长度  `-->` 结果为页号，余数为偏移地址。**  **（十进制计算）**

- **页内偏移地址 = 块内偏移地址**  

- **页面大小 = 页框大小**

- 页面大小也可根据 **页内偏移量位** 数来计算，**【若页内偏移量为 5 位，则页面大小为 2^5 = 32B】，<u> 页面数量由页号位数决定 </u>**

- **页框大小是根据块内偏移量，物理块数量由块号位数决定**

- **物理地址 = 块号 `*` 页面大小+块内偏移地址** （十进制计算）  
  - 若题设为求十进制物理地址，则直接进行计算  
  - **若题设为求非十进制物理地址，先将逻辑地址转换为二进制地址，然后需找出页号位数（若有 m 位表示页号位，则一个进程最多有 2^m 个页面）若有 m 位则二进制前 m 个表示页号剩余部分表示偏移量，再将页号部分转成十进制 ，根据页号的十进制找到物理块号 ，最后将该物理块号转成二进制，和前面剩余的偏移量二进制拼接起来，最后根据题设所需再转成相应进制。**  

**注：若页号大于题中所给的则会产生越界中断**  



### :star:基本分页中访问有效时间 EAT  

**访问一个内存（逻辑地址）的平均耗时（<u> 页面平均访问时间 </u>），其中：λ 表示查找快表所需时间，a 表示命中率，t 表示访问一次内存所需时间**  

- <span style="color:#FF3333; font-size:1.7em;"> **先查快表再查慢表：** </span>

  - $$
    一级页表：EAT = a *(t+λ)+(2t+λ)*(1-a)= 2t+λ-t * a                                \\
    二级页表：EAT = a *(t+λ)+(3t+λ)*(1-a)= 3t+λ-2t * a                                \\
    n 级页表：EAT = a *(t+λ)+[(n+1)t+λ)]*(1-a)=(n+1)*t+λ-n* a*t
    $$

    - **【若要考虑更新快表，则上述 λ 均变为 2λ】**

- **快表和慢表同时查询时间为：**

  -  
    $$
    EAT  = (λ+t)* a + (t+t)*(1-a)
    $$
    
  
- **未采用快表查询时间为：t+t**


![image-20241026152012740](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261520807.png)  

**解：**  

- **若采用先查快表再查慢表方式为：λ = 1，t = 100，a = 90% 则 EAT = 2 `*` 100 + 1- 100 `*` 90% = 111us**  
- **若采用快表和慢表同时查询的方式所需时间为：（1+100）`*` 0.9 + (100+100)`*` 0.1 = 110.9us**  
- **若未采用快表机制则时间为：100+100 = 200us**  

### :star:二级页表（多级页表）

**多级页表中，各级页表大小不能超过一个页面**

- 二级页表大小 = 页大小 = 块大小  
- **页表项个数 = 页大小 / 页表项大小**   **=  2^页表项位数**
- **页表项位数 = 页号位数**  ，**若是在多级页表中 2^页表项位数 = 页面大小 / 页表项大小**
  - **:star:几级页表个数 = 页号总位数 / 每页页表项位数 （向上取整=>大于等于）**   


<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261612574.png" alt="image-20241026161200471" style="zoom:67%;" />  

**解**：逻辑地址空间大小 = 2^16 * 2^10 = 2^26B ，则逻辑地址位数为 26 位。  

因为页大小为 2^10B，则页内偏移量位为 10 位。  

页表项个数 = 2^10 / 2 = 2^9B，故页表项位数为 9 位即页号位为 9 位。  

综上，页目录位 = 26-10-9 = 7 位，故页目录个数为 2^7 = 128 个  

![image-20241026163934637](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261639718.png)

**解：页面大小为 4KB = 2^12B，则页内偏移量位数为 12 位，则页号位数为 48-12 = 36 位**

**页表项大小为 B8 = 2^3B，则每个页面页表项个数为 2^12 / 2^3 = 2^9，则页表项位数为 9 位**。

**故几级页表 = 36 /9 = 4 级                       答案选 C**



## 基本分段存储

逻辑地址通常由两个部分组成：逻辑地址的形式为：**(段号, 段内偏移量)**。

- **段号 (Segment Number)**: 表示要访问的段。
- **段内偏移量 (Offset)**: 表示在该段内的具体位置。

### 逻辑地址怎么转化为物理地址

**段首址（基址）+段内偏移量（= 物理块内偏移量）**

**注：段首址根据段号来得到**

## 段页式存储管理

**按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）**

- **对用户：逻辑地址结构划分为段号、段内地址**
- **对系统：逻辑地址结构划分划分为段号、页号、页内地址（页内偏移量）三部分组成**

**其中：段长决定段内地址位数、段号的位数决定了每个进程最多可以分几段、页号的位数决定了每个段最大有多少页，页内偏移量决定了页面的大小、内存块的大小是多少**

## 请求分页中访问内存的有效时间

**:warning:请求分页存储管理访问内存的有效时间**

（λ为查找快表的时间，t为访问内存的时间）

- 被访问页在内存中，且对应的页表项在快表中：EAT = λ  + t
- 被访问页在内存中，其对应的页表项不在快表中时，EAT =  λ + t  + λ + t = 2(  λ + t ) 
- 被访问页不在内存中，假设缺页中断为s，则EAT =   λ + t + s +   λ + t = s + 2(  λ + t )
- 考虑快表的命中率为a和缺页率为f时，则EAT  =   λ + at + (1-a)[t+f(s + λ + t ) + (1-f)(  λ + t )] 
- 如果不考虑命中率，仅考虑缺页率f，设缺页中断时间为p ，则EAT = t + f(p + t) + (1 - f)t

已知内存存取时间为 1 s 用时为 t，未修改页处理缺页中断用时为 a，修改页处理缺页中断时间为 b，缺页率为 P，假定 q 被替换的页被修改过，此时访问内存有效时间为：

- 未缺页，直接访问内存时间为：t
- 缺页未修改访问内存时间为：t+a
- 缺页且修改访问内存时间为：t+b

**公式为：**
$$
EAT = (1-P)*t+(1-q)* P *(t+a)+q* P*(t+b)
$$


## 页面置换算法（请求分页）

页面失效次数 = <span style="color:#FF0000;"> **缺页次数为：刚开始新插入元素的列数+发生置换的列数** </span>

### 最佳置换算法 OPT（淘汰未来最远出现的）

- 选择的被淘汰页面是以后 **永不使用的，或者长时间不再被访问（未来最远出现）** 的页面
- **性能最好，但该算法无法实现**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271827663.png" alt="image-20241027182711481" style="zoom: 50%;" />

### :star:先进先出置换算法 FIFO

- 1、淘汰在 **内存中停留时间最长** 的页面 **2、实现容易，但性能稍差，而且 belady 异常会发生在算法中**   3、**没有基于局部性原理**
- :star: **淘汰最早进入内存页面===> 根据装入内存时间**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271836306.png" alt="image-20241027183634180" style="zoom:50%;" />

### :star:最近最少使用置换算法 LRU（淘汰过去最远的）

- **1、性能最接近 OPT 算法，但需要硬件支持，开销大**        2、**基于局部性原理**
- :star: **淘汰最长时间未被访问===> 根据最小的上次访问时间**



<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271912475.png" alt="image-20241027191232389" style="zoom:80%;" />

### :star:Clock 置换算法

- **某页刚进入内存或发生置换的时候**，该页其访问位 **置为 1**。
- 若需 **淘汰** 某个页面时，只需 **检查访问位是否为 0**，**若访问位置为 0（最先访问）将此页换出，并将新换新页，访问位 置为 1，同时指针下移。**
- 如果 **访问位为 1**，**将其置为 0 不置换新页，指针下移。**
- 若 **不需要淘汰页面（或者不发生缺页）指针不动，并将该页访问位置为 1**

<span style="color:#FF3333; font-size:0.9em;"> **注：若上一次指针所在位置刚好为 1，则下一次淘汰页面时，先将上一次指针所在的访问位置为 0，后指针下移** </span>

【Clock 置换算法原理+例题讲解】https://www.bilibili.com/video/BV1LZ421z7vJ?vd_source = c8b64e308ba0a6999b868fdf4177d69f

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271942845.png" alt="image-20241027194254700" style="zoom: 80%;" />

#### :star:改进型 CLOCK 置换算法

- **改进型CLOCK从上一次的位置开始扫描，首先寻找未被访问和未修改的页面，（读位和修改位都为0）因此最先淘汰该页面。**

  - **增加了修改位 M，未修改为 0，已修改为 1**

  <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410272059716.png" alt="image-20241027205926627" style="zoom:80%;" />

  **例题：**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410272107577.png" alt="image-20241027210721467" style="zoom: 50%;" />
$$

$$


## :star:混合索引分配相关习题

**注意：**

- **实际占用空间大小 = 文件实际大小+间接索引项大小+地址项数量（一般为 i node 数据结构）（含直接、间接）**

- **占用盘块数量为：文件长度/磁盘块大小 + 间接索引块数量（含一级、二级...）**

- :star:**占用多少盘块、占用多少空间该类题目的解题思路**
  - **文件占用多少盘块数：文件总长度 / 每个数据块的大小  记为a**：
  - **每个盘块可以存储多少个盘块号（根据盘块大小以及每个盘块号的大小  两个相除  记为b）**
  - **直接地址项：每个直接地址项可以直接指向一个盘块。因此，n个直接地址项可以指向n个盘块。**
  - **一级地址项：使用一个间接索引块，共可记录a个盘块**
  - **二级地址项：通过一个索引表的索引表来指向多个盘块，此时所需索引块数为：1+ ┍ (a - n -b  )  / b  ┑      （符号『 为向上取证 ） **
  - **总共需要：文件长度/磁盘块大小 + 间接索引块数量   === >   a + 1 + 1+ ┍ (a - n -b  )  / b  ┑ **




![image-20241030221611198](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410302216296.png)

【**解答**】https://www.bilibili.com/video/BV18P411J7Z1?vd_source = c8b64e308ba0a6999b868fdf4177d69f

![image-20241031230538564](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312305633.png)

![image-20241031225507615](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312255685.png)

**解答**：

![image-20241031231027928](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312310009.png)

![image-20241031230257417](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312302495.png)



##  磁盘调度算法

- **FCFS：磁头移动顺序为默认顺序**
- **SSTF：磁头移动顺序为：选择与当前磁头所在磁道距离最近的磁道**

------

**先进行从大到小排序**

------

- **SCAN（电梯调度算法）：先将磁头当前所在磁道与其他磁头序列进行从大到小排序，根据磁头移动方向选择朝哪边移动，到达尽头后朝反方向移动（已访问的磁头不会再次访问）**

- **磁盘磁道是越往里磁盘号越大，如果磁头是从里向外移动即为朝小的方向移动，如果是从外向里即为朝大的方向移动**

- **LOOK：同 SCAN 算法一样，LOOK 算法只需走到该方向上最后一个请求就会转换方向**
- **C-SCAN（循环电梯调度算法）：类似与 SCAN 算法，到磁盘尽头（最小柱面号）后直接返回到磁盘另一端（最大柱面号） （单向移动）**
- **C-LOOK：同 C-SCAN 算法一样，只需走到该方向上最后一个请求（不用走到尽头）就会跳转到另一端开始位置（序列另一端）**
