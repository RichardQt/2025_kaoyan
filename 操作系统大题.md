# 操作系统小题

## 填空

### 第一章 概论

- 计算机系统是由硬件系统和软件系统
- 多道程序设计技术能充分发挥CPU与外设并行工作的能力，多道程序设计特点：多道、宏观上并行、微观上串行。
- 程序并发执行与顺序执行相比多了些新的特征：分别是：并发、共享、不确定性（不可再现性、异步性）
- 并发和共享是操作系统两个最基本的特征
- 操作系统中不可中断执行的操作称为：原语
- 分时操作系统主要特征：及时性、交互性、独立性。分时操作系统是在用户态下执行
- 实时操作系统两个基本特征：及时性和高可靠性
- 批处理操作系统不允许用户随时干预自己程序的运行

### 第二章 进程管理

- 进程的三种基本状态：运行、阻塞、就绪
- 多个程序同时装入一个计算机系统的主存中并行执行，这个程序设计技术称为：多道程序设计
- 进程由程序段、数据段、进程控制块（PCB）组成的。其中进程控制块是保存进程状态、控制进程转换的标志，也是进程存在的唯一标志。进程控制块的初始化工作包括：初始化标识符信息、初始化处理及状态信息、初始化处理机控制信息。
- 引入线程前：进程是资源分配、调度和管理的最小单位。若引入线程后：进程是拥有资源基本单位、线程是独立调度基本单位。
- 进程的基本特征：动态、并发 独立、异步、结构特征。
- 若有五个用户进程，则处于就绪状态下进程最多有五个，最少有0个。若处于用户态（即某用户程序正在运行）则处于就绪状态下的用户进程最多有四个，最少有0个。
- 进程调度解决的是把cpu如何有效分配给进程
- 系统中各进程之间的逻辑上的相互制约关系称为同步。互斥是指进程间在使用共享资源方面的约束关系
- 临界资源的概念是一次仅允许一个进程访问资源，而临界区是指进程中访问临界资源的那段程序代码。
- 信号量大于0表示：可用资源数目。信号量小于0的绝对值为请求资源被阻塞进程的数目。:star:
- 任何一个进程进入临界区之前调用wait操作，退出临界区应调用signal操作
- 有m个进程共享同一临界资源，若 使用信号量机制实现对资源的互斥访问，信号量值的变化范围：【-m+1，1】
- 操作系统中，对信号量s的wait原语操作定义中，使进程进入相应等待队列的等待的条件：s<0
- 当系统采用资源有效分配方法预防死锁，它破坏了产生死锁的必要条件中的环路等待条件
- 在有m个进程的系统中出现死锁，死锁进程的个数k应该满足的条件为：2<= k <=m（至少需要两个进程互相等待才能形成循环等待）
- 

### 第三章

### 第四章

### 第五章





#  操作系统应用题

## 作业调度七种算法

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231908412.png" alt="image-20241023190820258" style="zoom:67%;" />  

### 先来先服务算法(FCFS)

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231909783.png" alt="image-20241023190959697" style="zoom: 67%;" />  

### 短作业优先算法(SJF)

**注：不同到达时间，<u>先到达的作业优先执行</u>，当执行完的时候看其他几个作业是否到达，如果剩下作业都到达按照短作业优先”**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231911235.png" alt="image-20241023191142172" style="zoom: 67%;" />  

#### 非抢占

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231912394.png" alt="image-20241023191214346" style="zoom:67%;" />  

#### 抢占

- **基于最短剩余时间(SRTN)**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231914174.png" alt="image-20241023191413120" style="zoom:67%;" />  

**注：当 D 执行到第八秒的时候，D 还剩 2 秒要小于 E 服务时间 4 秒故还是先执行完 D 再执行 E**  

### 优先级别调度算法

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231921740.png" alt="image-20241023192100671" style="zoom:67%;" />  

### 高响应比调度算法(HRRN)

**响应比=1+ 等待时间 / 服务时间**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231924212.png" alt="image-20241023192419032" style="zoom:67%;" />  

<span style="color:#FF0000;">**注：等待时间为调度时间减去到达时间（单位：分钟），先算出第一次调度优先级，当计算第二次调度作业时第二次调度的开始时间要变为第一次调度开始时间再加上最先调度作业的服务时间**  </span>

**（第二次调度时间开始为 10：40，等待时间 = 开始时间 - 到达时间）**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410231934608.png" alt="image-20241023193404502" style="zoom:67%;" />  

### 时间片轮转调度算法（RR）

#### 不同到达时间

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232049804.png" alt="image-20241023204948616" style="zoom: 50%;" />  

**解题思路：当不再加入新任务时，即此时时间来到第四秒结束，此时序列为 BDAEC，后一直按照此序列重复下去，若某一作业当满足服务时间后，去除该作业，其他作业继续重复，直到全部满足。**  

**当 q(时间片)为 4 的时候为最大服务时间则不会执行时间片轮转改为先来先服务算法（FCFS）**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232052592.png" alt="image-20241023205202535" style="zoom: 80%;" />  

#### 相同到达时间

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232300936.png" alt="image-20241023230054832" style="zoom:67%;" />  

**解题思路：相同到达时间即一直重复 ABCDE，若某一作业当满足服务时间后，去除该作业，其他作业继续重复，直到全部满足**  

![image-20241023230136540](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232301599.png)  

**当 q(时间片)为 4 的时候为最大服务时间则不会执行时间片轮转改为先来先服务算法（FCFS）**  

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410232306269.png" alt="image-20241023230651200" style="zoom: 80%;" />  

### 最早截止时间算法（EDF）

- 抢占  
  - 【实时调度算法之最早截止时间优先调度算法（抢占）】https://www.bilibili.com/video/BV1zD421n7Rs?vd_source = c8b64e308ba0a6999b868fdf4177d69f  
- 非抢占  
  - 【实时调度算法之最早截止时间优先调度算法（非抢占）】https://www.bilibili.com/video/BV1Tt421E7i3?vd_source = c8b64e308ba0a6999b868fdf4177d69f  

**注：开始执行时间 > 最早截止时间则该任务不能被调度**  



### 最低松弛度优先算法(LLF)

![image-20241026124145950](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261241002.png)  

【实时调度算法之最低松弛度优先算法】https://www.bilibili.com/video/BV17M4m1X7MT?vd_source 

## pv 操作考代码

## 死锁、银行家算法

【操作系统银行家算法例题讲解】https://www.bilibili.com/video/BV1gK411x7Ra?vd_source 

- **Need矩阵是怎样的？** 

  - **Need = Max - allocation**

- **系统是否处于安全状态？如安全，请给出一个安全序列。** 

  - **work(available) >= need满足安全**

- **若从进程P1发来一个请求(0,4,2,0)，这个请求能否立刻被满足？如安全，请给出一个安全序列。**

  - **Available = available - request**

  - **Allocation = allocation + request**

  - **Need = need - request**


## 动态分区分配算法（连续分配）

- 首次适应  
  - **从头部开始查找，找到第一个能满足大小的空闲分区**  
- 最佳适应  
  - 将空闲分区按容量进行从**小到大排序，选满足的第一个空闲分区**  
- 最坏适应  
  - 将空闲分区按容量进行**从大到小排序，选满足的第一个空闲分区**  
- 邻近适应（循环首次适应）  
  - 从上次查找结束的位置开始检索  
  - 算法开销小，但会使高地址的大分区被用完  

### 分区回收

【【操作系统】【考研真题】2017年第25题【动态分区存储管理】分区分配与回收】https://www.bilibili.com/video/BV1Zd4y127Bd?vd_source=c8b64e308ba0a6999b868fdf4177d69f

【「操作系统题目」动态分区分配和回收算法】https://www.bilibili.com/video/BV1Ap4y167A9?vd_source=c8b64e308ba0a6999b868fdf4177d69f

## 基本分页存储管理（非连续分配）

### 逻辑地址、物理地址转换

- 逻辑地址位数可根据逻辑空间大小来计算，**若逻辑空间大小为 2^10B，则逻辑地址位数为 10 位**  

- **用逻辑地址除以页面长度  `-->` 结果为页号，余数为偏移地址。**  

- **页内偏移地址 = 块内偏移地址**  

- **页面大小 = 页框大小**

- 页面大小也可根据 **页内偏移量位** 数来计算，**【若页内偏移量为 5 位，则页面大小为 2^5 = 32B】，<u>页面数量由页号位数决定</u>**

- **页框大小是根据块内偏移量，物理块数量由块号位数决定**

- **物理地址 = 块号 `*` 页面大小+块内偏移地址** （十进制计算）  
  - 若题设为求十进制物理地址，则直接进行计算  
  - **若题设为求非十进制物理地址，先将逻辑地址转换为二进制地址，然后需找出页号位数（若有 m 位表示页号位，则一个进程最多有 2^m 个页面）若有 m 位则二进制前 m 个表示页号剩余部分表示偏移量，再将页号部分转成十进制 ，根据页号的十进制找到物理块号 ，最后将该物理块号转成二进制，和前面剩余的偏移量二进制拼接起来，最后根据题设所需再转成相应进制。**  

**注：若页号大于题中所给的则会产生越界中断**  



### 基本分页中访问有效时间 EAT  

**访问一个内存（逻辑地址）的平均耗时（<u>页面平均访问时间</u>），其中：λ 表示查找快表所需时间，a 表示命中率，t 表示访问一次内存所需时间**  

- <span style="color:#FF3333; font-size:1.7em;">**先查快表再查慢表：**</span>

  - $$
    一级页表：EAT = a*(t+λ)+(2t+λ)*(1-a)=2t+λ-t * a                                \\
    二级页表：EAT = a*(t+λ)+(3t+λ)*(1-a)=3t+λ-2t * a                                \\
    n级页表：EAT = a*(t+λ)+[(n+1)t+λ)]*(1-a)=(n+1)*t+λ-n*a*t
    $$

    - **【若要考虑更新快表，则上述λ均变为2λ】**

- **快表和慢表同时查询时间为：**

  -  
    $$
    EAT  = (λ+t)* a + (t+t)*(1-a)
    $$
    


![image-20241026152012740](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261520807.png)  

**解：**  

- **若采用先查快表再查慢表方式为：λ = 1，t = 100，a = 90% 则 EAT = 2 `*` 100 + 1- 100 `*` 90% = 111us**  
- **若采用快表和慢表同时查询的方式所需时间为：（1+100）`*` 0.9 + (100+100)`*` 0.1 = 110.9us**  
- **若未采用快表机制则时间为：100+100 = 200us**  

### 二级页表（多级页表）

**多级页表中，各级页表大小不能超过一个页面**

- 二级页表大小 = 页大小 = 块大小  
- **页表项个数 = 页大小 / 页表项大小**   **=  2^页表项位数**
- **页表项位数 = 页号位数**  ，**若是在多级页表中 页表项位数 = 页面大小 / 页表项大小**
  - **几级页表个数 = 页号总位数 / 每页页表项位数 （向上取整）**   


<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261612574.png" alt="image-20241026161200471" style="zoom:67%;" />  

**解**：逻辑地址空间大小 = 2^16 * 2^10 = 2^26B ，则逻辑地址位数为 26 位。  

因为页大小为 2^10B，则页内偏移量位为 10 位。  

页表项个数 = 2^10 / 2 = 2^9B，故页表项位数为 9 位即页号位为 9 位。  

综上，页目录位 = 26-10-9 = 7 位，故页目录个数为 2^7 = 128 个  

![image-20241026163934637](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410261639718.png)

**解：页面大小为 4KB = 2^12B，则页内偏移量位数为 12 位，则页号位数为 48-12 = 36 位**

**页表项大小为 B8 = 2^3B，则每个页面页表项个数为 2^12 / 2^3 = 2^9，则页表项位数为 9 位**。

**故几级页表 = 36 /9 = 4 级                       答案选 C**



## 基本分段存储

逻辑地址通常由两个部分组成：逻辑地址的形式为：**(段号, 段内偏移量)**。

- **段号 (Segment Number)**: 表示要访问的段。
- **段内偏移量 (Offset)**: 表示在该段内的具体位置。

### 逻辑地址怎么转化为物理地址

**段首址（基址）+段内偏移量（=物理块内偏移量）**

**注：段首址根据段号来得到**

## 段页式存储管理

**按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）**

- **对用户：逻辑地址结构划分为段号、段内地址**
- **对系统：逻辑地址结构划分划分为段号、页号、页内地址（页内偏移量）三部分组成**

**其中：段长决定段内地址位数、段号的位数决定了每个进程最多可以分几段、页号的位数决定了每个段最大有多少页，页内偏移量决定了页面的大小、内存块的大小是多少**

## 分页式、段式、段页式访问内存次数及其过程

**在页式存储管理中，访问指令或数据时，首先要访问内存中的页表，查找到指令或数据所在页面对应的页表项，然后根据页表项查找访问指令或数据所在的内存页面。需要访问内存2次。**

**段式存储管理同理，需要访问内存2次。**

**段页式存储管理，首先要访问内存中的段表，然后访问内存中的页表，最后访问指令或数据所在的内存页面，需要访问内存3次。对于比较复杂的情况，如多级页表，若页表划分为N级，则需要访问内存N+1次。若系统中有快表，则在快表命中时，只需要访问内存1次。**

## 页面置换算法（请求分页）

页面失效次数 = <span style="color:#FF0000;">**缺页次数为：刚开始新插入元素的列数+发生置换的列数**</span>

### 最佳置换算法OPT（淘汰未来最远出现的）

- 选择的被淘汰页面是以后**永不使用的，或者长时间不再被访问（未来最远出现）**的页面
- **性能最好，但该算法无法实现**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271827663.png" alt="image-20241027182711481" style="zoom: 50%;" />

### 先进先出置换算法FIFO

- 淘汰在**内存中停留时间最长**的页面

- **实现容易，但性能稍差，而且belady异常会发生在算法中**
- **没有基于局部性原理**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271836306.png" alt="image-20241027183634180" style="zoom:50%;" />

### 最近最久未使用置换算法LRU（淘汰过去最远的）

- **性能最接近OPT算法，但需要硬件支持，开销大**
- **基于局部性原理**



<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271912475.png" alt="image-20241027191232389" style="zoom:80%;" />

### Clock置换算法

- **某页刚进入内存或发生置换的时候**，该页其访问位**置为1**。
- 若需**淘汰**某个页面时，只需**检查访问位是否为0**，**若访问位置为0（最先访问）将此页换出，并将新换新页，访问位 置为1，同时指针下移。**
- 如果**访问位为1**，**将其置为0不置换新页，指针下移。**
- 若**不需要淘汰页面（或者不发生缺页）指针不动，并将该页访问位置为1**

<span style="color:#FF3333; font-size:0.9em;">**注：若上一次指针所在位置刚好为1，则下一次淘汰页面时，先将上一次指针所在的访问位置为0，后指针下移**</span>

【Clock置换算法原理+例题讲解】https://www.bilibili.com/video/BV1LZ421z7vJ?vd_source=c8b64e308ba0a6999b868fdf4177d69f

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410271942845.png" alt="image-20241027194254700" style="zoom: 80%;" />

#### 改进型CLOCK置换算法

- **增加了修改位M，未修改为0，已修改为1**

  <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410272059716.png" alt="image-20241027205926627" style="zoom:80%;" />

  **例题：**

<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410272107577.png" alt="image-20241027210721467" style="zoom: 50%;" />



### 请求分页中访问内存的有效时间

已知内存存取时间为1 s用时为t，未修改页处理缺页中断用时为a，修改页处理缺页中断时间为b，缺页率为P，假定 q被替换的页被修改过，此时访问内存有效时间为：

- 未缺页，直接访问内存时间为：t
- 缺页未修改访问内存时间为：t+a
- 缺页且修改访问内存时间为：t+b

**公式为：**
$$
EAT = (1-P)*t+(1-q)*P*(t+a)+q*P*(t+b)
$$


## 混合索引分配相关习题

**注意：**

- **实际占用空间大小=文件实际大小+间接索引项大小+地址项数量（一般为i node 数据结构）（含直接、间接）**

- **占用盘块数量为：文件长度/磁盘块大小 + 间接索引块数量（含一级、二级...）**



![image-20241030221611198](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410302216296.png)

【**解答**】https://www.bilibili.com/video/BV18P411J7Z1?vd_source=c8b64e308ba0a6999b868fdf4177d69f

![image-20241031230538564](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312305633.png)

![image-20241031225507615](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312255685.png)

**解答**：

![image-20241031231027928](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312310009.png)

![image-20241031230257417](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202410312302495.png)



##  磁盘调度算法

- **FCFS：磁头移动顺序为默认顺序**
- **SSTF：磁头移动顺序为：选择与当前磁头所在磁道距离最近的磁道**
- **SCAN（电梯调度算法）：先将磁头当前所在磁道与其他磁头序列进行从大到小排序，根据磁头移动方向选择朝哪边移动，到达尽头后朝反方向移动（已访问的磁头不会再次访问）**
  - **磁盘磁道是越往里磁盘号越大，如果磁头是从里向外移动即为朝小的方向移动，如果是从外向里即为朝大的方向移动**
- **LOOK：同SCAN算法一样，LOOK算法只需走到该方向上最后一个请求就会转换方向**
- **C-SCAN（循环电梯调度算法）：类似与SCAN算法，到磁盘尽头（最小柱面号）后直接返回到磁盘另一端（最大柱面号） （单向移动）**
- **C-LOOK：同C-SCAN算法一样，只需走到该方向上最后一个请求（不用走到尽头）就会跳转到另一端开始位置（序列另一端）**
