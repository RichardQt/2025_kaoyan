# 代码

## 数据结构代码

### 链表

**在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点 不唯一，试编写算法以实现上述操作。**



### **二叉树**

### 

### 查找和排序

#### 二分查找的非递归算法

#### 快速排序

#### 希尔排序

#### 冒泡排序

#### 归并排序

#### 直接插入排序







## 操作系统代码---PV操作

### 前驱图，伪代码：

1、**试画出下面四条语句的前趋图，若四条语句并发执行，写出保证其运行正确 性的伪代码，给所用变量添加注释。** 

**Q1: x=a+b; Q2:y=c-d; Q3: z=x+y; Q4: u=z*y**

```c
// 初始化信号量，所有信号量初始值为 0
// 这意味着所有的资源都被锁定，必须等待释放
semaphore x1 = y1 = z1 = 0;

// Q1: 计算 x = a + b
Q1() {
  // 执行计算 x = a + b
  x = a + b;

  // V(x1): 释放信号量 x1，表示 Q1 已完成，通知 Q3 可以开始执行
  V(x1);  // 释放信号量 x1，允许 Q3 使用 x
}

// Q2: 计算 y = c - d
Q2() {
  // 执行计算 y = c - d
  y = c - d;

  // V(y1): 释放信号量 y1，表示 Q2 已完成，通知 Q3 可以开始执行
  V(y1);  // 释放信号量 y1，允许 Q3 使用 y
}

// Q3: 计算 z = x + y
Q3() {
  // P(x1): 请求信号量 x1，等待 Q1 完成计算 x
  P(x1);  // 请求信号量 x1，确保 Q3 在 Q1 完成后才能执行

  // P(y1): 请求信号量 y1，等待 Q2 完成计算 y
  P(y1);  // 请求信号量 y1，确保 Q3 在 Q2 完成后才能执行

  // 执行计算 z = x + y
  z = x + y;

  // V(z1): 释放信号量 z1，表示 Q3 已完成，通知 Q4 可以开始执行
  V(z1);  // 释放信号量 z1，允许 Q4 使用 z
}

// Q4: 计算 u = z * y
Q4() {
  // P(z1): 请求信号量 z1，等待 Q3 完成计算 z
  P(z1);  // 请求信号量 z1，确保 Q4 在 Q3 完成后才能执行

  // 执行计算 u = z * y
  u = z * y;
}

```

**备注：**

- 前驱图考的是同步关系，所以信号量初值都设为0
- 在同步操作中，先有V再有P，其中P是申请资源，V是释放资源

2、**[2020统考真题]现有5个操作A、B、C、D和E，操作C必须在A和B完成后执行， 操作E必须在C和D完成后执行，请使用信号量的wait()、 signal()操作(P、V操作) 描述上述操作之间的同步关系，并说明所用信号量及其初值。**

![image-20241130031835252](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411300318321.png)

```c
semaphore s1=s2=s3=s4=0;  // 初始化所有信号量为0

void A() {
    // 执行A的操作
    V(s1);    // 释放资源,通知C可以使用A的结果
}

void B() {
    // 执行B的操作
    V(s2);    // 释放资源,通知C可以使用B的结果
}

void C() {
    P(s1);    // 申请A的资源,等待A完成
    P(s2);    // 申请B的资源,等待B完成
    // 执行C的操作
    V(s3);    // 释放资源,通知E可以使用C的结果
}

void D() {
    // 执行D的操作
    V(s4);    // 释放资源,通知E可以使用D的结果
}

void E() {
    P(s3);    // 申请C的资源,等待C完成
    P(s4);    // 申请D的资源,等待D完成
    // 执行E的操作
}
```

3、现有5个操作A、B、C、D、E、F，操作C必须在B完成后执行，操作D必须在A完成后执行，操作E必须在D和C完成后执行，操作F必须在E完成后执行，请使用P、V操作描述上述的同步关系，并说明所用信号量及其初值。
<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411301714307.png" alt="image-20241130171404180" style="zoom:50%;" />

```c
semaphore a=b=c=d=e=0;  // 初始化所有信号量为0

void A() {
    执行A的操作;
    V(a);    // 释放资源,通知D可以使用A的结果
}

void B() {
    执行B的操作;
    V(b);    // 释放资源,通知c可以使用B的结果
}

void C() {
    P(b);    // 申请A的资源,等待A完成
    执行C;
    V(c);    // 释放资源,通知e可以使用C的结果
}

void D() {
    P(a)
    执行D;
    V(d);    // 释放资源,通知E可以使用D的结果
}

void E() {
    P(c);    // 申请C的资源,等待C完成
    P(d);    // 申请D的资源,等待D完成
    执行E的操作;
    V(e)

}
void F() {
    P(e);    // 申请e的资源,等待C完成
    执行F;

}
```



### 生产者与消费者问题：

**题目**：

一组生产者进程和一组消费者进程共享一个初始为空，大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待;只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。**由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息**。

```c
semaphore mutex=1;   // 互斥锁，保证对共享缓冲区的互斥访问
semaphore empty=n;   // 表示空缓冲区数量，初始值为缓冲区的总大小
semaphore full=0;    // 表示满缓冲区数量，初始值为0，因为开始时缓冲区是空的

produce() { // 生产者函数
    while (1) {
        生产数据;         // 生成新数据（此步独立执行，不涉及共享资源）
        P(empty);          // 在缓冲区申请一个空间用于放数据
        P(mutex);          // 申请互斥锁，进入临界区
        放入数据;         // 将生产的数据放入缓冲区
        V(mutex);          // 释放互斥锁，离开临界区
        V(full);           // 此时缓冲区有数据并通知消费者
    }
}

consumer() { // 消费者函数
    while (1) {
        P(full);           // 消费者会先判断缓冲区里是否有数据，如果有数据则执行下述操作
        P(mutex);          // 申请互斥锁，进入临界区
        取出数据;         // 从缓冲区中取出数据
        V(mutex);          // 释放互斥锁，离开临界区
        V(empty);          //消费者取完数据后，空间被释放
        消费数据;         // 消费数据（此步独立执行，不涉及共享资源）
    }
}

main() {
    parbegin(produce(), consumer()); // 并发执行生产者和消费者
}

```

#### 小和尚提水、老和尚饮水问题（生产者消费者变形）

**题目：**

   某寺庙，有小和尚、老和尚若干．庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳 30 桶水，**每次入水、取水仅为1 桶，不可同时进行**。水取自同一井中，水井径窄，**每次只能容纳一个水桶取水**。设水桶个数为5 个，试用信号量和PV 操作给出老和尚和小和尚的活动。

**分析：**

两个进程：小和尚和老和尚

小和尚每次去水井取水的时候只能允许一个小和尚进行取水（添加互斥），取完放到水缸中也是只允许一个小和尚放（添加互斥）,老和尚取水的时候也只允许一个老和尚进行取水（添加互斥）

**设水井和水缸为临界资源，设为mutex1,mutex2；设水桶数量为cnt，初始值为5**`

```c
semaphore mutex1=1, mutex2=1, empty=30, full=0, cnt=5;

/*
 * mutex1 - 井中取水互斥
 * mutex2 - 缸中入水/取水互斥
 * empty - 初始值为30，表示水缸中的空位数
 * full - 初始值为0，表示水缸中的水量
 * cnt - 初始值为5，表示水桶数
 */

void young() { // 小和尚
    while (true) {
        p(empty);      // 申请一个空位资源，等待有空位
        p(cnt);        // 申请一个空桶资源，等待有空桶
        p(mutex1);     // 申请取水互斥访问权，确保只有一个小和尚在井中取水
        从井中取水;   // 执行取水操作
        v(mutex1);     // 释放取水互斥访问权
        p(mutex2);     // 申请入水互斥访问权，确保只有一个小和尚在水缸中放水
        送水到水缸;   // 执行送水操作
        v(mutex2);     // 释放入水互斥访问权
        v(cnt);        // 释放空桶资源
        v(full);       // 表示水缸中的水量增加，信号量+1
        //这里水并没有被取走，所以不用释放empty
    }
}

void senior() { // 老和尚
    while (true) {
        p(full);       // 判断信号量是否大于0
        p(cnt);        // 申请一个空桶资源，等待有空桶
        p(mutex2);     // 申请取水互斥访问权，确保只有一个老和尚在水缸中取水
        从缸中取水;   // 执行取水操作
        v(mutex2);     // 释放取水互斥访问权
        v(cnt);        // 释放空桶资源
        v(empty);      // 老和尚取完水后，释放一个空位资源，表示水缸中的空位增加
    }
}

void main() {
    parbegin(young(), senior()); // 并发执行小和尚和老和尚的操作
}

```



### 读者与写者问题

**题目**

有读者和写者并发进程，共享文件，允许多个读者同时对文件采取读操作，读的时候不可以写；每次只允许一个写者在文件中写，写的时候不允许任何人读

**分析**

 自己理解方式：每个读者在进来读书和走的时候都需要进行登记，第一个读者进入的时候，需要确保没有写者在写书，故需要申请读写互斥锁，这个锁就像是请勿打扰的牌子

当其他读者进来时，登记完直接读书就行，不需要挂这个牌子；读者离开的时候要先登记后才能离开，当最后一个读者走的时候，摘下请勿打扰的牌子 ，并告知写者可以进来写书

```c
/*
 * 分析：先读在写，当所有人都读完了才可以写。
 * 设置信号量 读和写的互斥锁，防止读或写的时候被干扰。
 * 设置信号量 读者数量的互斥锁。
 * 设置信号量 读者数量，只有读者数量为0的时候才可以写。
 * 两个进程：一个读进程一个写进程。

 */

int cnt = 0; // 设置读者数量，一开始为0
semaphore rw = 1;    // 读写互斥锁
semaphore mutex = 1; // 读者数量互斥锁

void read() { // 读者函数
    while (1) {
        p(mutex);   // 申请互斥锁，进入临界区修改读者计数
        if (cnt == 0) {
            p(rw);  // 如果是第一个读者，申请读写互斥锁
        }
        cnt++;      // 读者数量加一
        v(mutex);   // 释放互斥锁，离开临界区

        // 读者读书
        读者正在读书;

        p(mutex);   // 申请互斥锁，进入临界区修改读者计数
        cnt--;      // 读者数量减一
        if (cnt == 0) {
            v(rw);  // 如果没有读者了，释放读写互斥锁，通知写进程可以写了
        }
        v(mutex);   // 释放互斥锁，离开临界区
    }
}

void write() { // 写者函数
    while (1) {
        p(rw);      // 申请读写互斥锁，确保没有读者在读
        // 写者写书
        写者正在写书
        v(rw);      // 释放读写互斥锁，允许其他读者或写者进入
    }
}

void main() {
    parbegin(read(), write()); // 并发执行读者和写者
}
```



#### 过独木桥问题（读者写者问题）

**题目：**

请用信号量解决以下的“过独木桥”问题:同一方向的行人可连续过桥， 当某一方向有人过桥时，另一方向的行人必须等待;当某一方向无人过桥时，另一方向的 行人可以过桥。 

**分析：**

两个进程：北向南过桥、南向北过桥

从北向南的行人开始过桥需要先登记，如果是第一个从北向南的行人需要申请桥的资源并挂一个请勿打扰的锁，确保另一方向的人不可以过桥；然后从北向南的其他行人依次过桥，每个行人过桥💰要登记，过完桥时也要登记，当最后一个北向南的行人离开时需要释放桥的资源，告知另一方向的人可以过桥

另一个方向的人同上述操作一样

```c
/*
 * 分析: 独木桥问题是读者-写者问题的一个变形。同一个方向的行人可以同时过桥，
 *       但不同方向的行人必须互斥地过桥。
 * 
 * 设置信号量:
 * - bridge: 控制桥上的互斥访问
 * - mutex: 控制对计数器的互斥访问
 * - north_count: 记录北向过桥行人数
 * - south_count: 记录南向过桥行人数
 */

semaphore bridge = 1;     // 独木桥互斥锁
semaphore mutex = 1;      // 计数器互斥锁
int north_count = 0;      // 北向过桥行人数
int south_count = 0;      // 南向过桥行人数

void north_person() { // 北向过桥行人过程
    while (1) {
        p(mutex);          // 进入临界区修改计数器
        if (north_count == 0) {
            p(bridge);     // 如果是第一个北向行人，申请桥的访问权
        }
        north_count++;     // 北向行人数加一
        v(mutex);          // 离开临界区

        // 行人过桥
        行人从北边过桥;

        p(mutex);          // 进入临界区修改计数器
        north_count--;     // 北向行人数减一
        if (north_count == 0) {
            v(bridge);     // 如果没有北向行人了，释放桥的访问权
        }
        v(mutex);          // 离开临界区
    }
}

void south_person() { // 南向过桥行人过程
    while (1) {
        p(mutex);          // 进入临界区修改计数器
        if (south_count == 0) {
            p(bridge);     // 如果是第一个南向行人，申请桥的访问权
        }
        south_count++;     // 南向行人数加一
        v(mutex);          // 离开临界区

        // 行人过桥
         行人从南边过桥;

        p(mutex);          // 进入临界区修改计数器
        south_count--;     // 南向行人数减一
        if (south_count == 0) {
            v(bridge);     // 如果没有南向行人了，释放桥的访问权
        }
        v(mutex);          // 离开临界区
    }
}

void main() {
    parbegin(north_person(), south_person()); // 并发执行北向和南向行人过桥
}

```

### 复杂PV操作

**总结：**

- **①找出进程角色，简写角色过程**
- **②互斥：有几个临界资源就设置几个互斥信号量**
- **③同步:列出必须有上一步才能执行下一步的过程,这里需要一个同步信号量**
- **④设置信号量初值（互斥信号量通常为 1，同步信号量根据依赖关系设置）。）**
- **⑤具体进程（P是申请资源，V是释放资源）**

⚠️**注意:**

**1、P操作（用于申请资源）：**

- **判断信号量的值**：
- - **如果信号量的值大于 0**，表示资源可用，进程可以继续执行。
  - **如果信号量的值为 0**，表示资源不可用，进程需要等待。
- **执行行为**：
- - 如果信号量的值大于 0，P 操作会将信号量减 1，表示资源被占用。
  - 如果信号量为 0，进程进入 **等待队列**，并暂停执行，直到信号量的值大于 0。

**2、V 操作（用于释放资源）**

- **增加信号量的值**：
- - 通过执行 V 操作，信号量的值加 1，表示资源的释放。
- **唤醒等待队列中的进程**：
- - 如果有其他进程因为信号量为 0 而等待，那么 V 操作会将信号量增加后，唤醒一个等待队列中的进程，让它重新进入就绪队列。

3、加互斥信号量的目的是为了 **确保对共享资源的互斥访问**，避免多个进程或线程同时访问同一资源。互斥信号量用于控制 **临界区** 的访问，确保在任意时刻，只有一个进程可以访问共享资源。

### 哲学家进餐问题？？？？？？？？





