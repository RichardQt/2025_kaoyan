# 代码

## 数据结构代码

## 操作系统代码---PV操作

### 前驱图，伪代码：

1、**试画出下面四条语句的前趋图，若四条语句并发执行，写出保证其运行正确 性的伪代码，给所用变量添加注释。** 

**Q1: x=a+b; Q2:y=c-d; Q3: z=x+y; Q4: u=z*y**

```c
// 初始化信号量，所有信号量初始值为 0
// 这意味着所有的资源都被锁定，必须等待释放
semaphore x1 = y1 = z1 = 0;

// Q1: 计算 x = a + b
Q1() {
  // 执行计算 x = a + b
  x = a + b;

  // V(x1): 释放信号量 x1，表示 Q1 已完成，通知 Q3 可以开始执行
  V(x1);  // 释放信号量 x1，允许 Q3 使用 x
}

// Q2: 计算 y = c - d
Q2() {
  // 执行计算 y = c - d
  y = c - d;

  // V(y1): 释放信号量 y1，表示 Q2 已完成，通知 Q3 可以开始执行
  V(y1);  // 释放信号量 y1，允许 Q3 使用 y
}

// Q3: 计算 z = x + y
Q3() {
  // P(x1): 请求信号量 x1，等待 Q1 完成计算 x
  P(x1);  // 请求信号量 x1，确保 Q3 在 Q1 完成后才能执行

  // P(y1): 请求信号量 y1，等待 Q2 完成计算 y
  P(y1);  // 请求信号量 y1，确保 Q3 在 Q2 完成后才能执行

  // 执行计算 z = x + y
  z = x + y;

  // V(z1): 释放信号量 z1，表示 Q3 已完成，通知 Q4 可以开始执行
  V(z1);  // 释放信号量 z1，允许 Q4 使用 z
}

// Q4: 计算 u = z * y
Q4() {
  // P(z1): 请求信号量 z1，等待 Q3 完成计算 z
  P(z1);  // 请求信号量 z1，确保 Q4 在 Q3 完成后才能执行

  // 执行计算 u = z * y
  u = z * y;
}

```

**备注：**

- 前驱图考的是同步关系，所以信号量初值都设为0
- 在同步操作中，先有V再有P，其中P是申请资源，V是释放资源

2、**[2020统考真题]现有5个操作A、B、C、D和E，操作C必须在A和B完成后执行， 操作E必须在C和D完成后执行，请使用信号量的wait()、 signal()操作(P、V操作) 描述上述操作之间的同步关系，并说明所用信号量及其初值。**

![image-20241130031835252](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411300318321.png)

```c
semaphore s1=s2=s3=s4=0;  // 初始化所有信号量为0

void A() {
    // 执行A的操作
    V(s1);    // 释放资源,通知C可以使用A的结果
}

void B() {
    // 执行B的操作
    V(s2);    // 释放资源,通知C可以使用B的结果
}

void C() {
    P(s1);    // 申请A的资源,等待A完成
    P(s2);    // 申请B的资源,等待B完成
    // 执行C的操作
    V(s3);    // 释放资源,通知E可以使用C的结果
}

void D() {
    // 执行D的操作
    V(s4);    // 释放资源,通知E可以使用D的结果
}

void E() {
    P(s3);    // 申请C的资源,等待C完成
    P(s4);    // 申请D的资源,等待D完成
    // 执行E的操作
}
```



#### 小和尚提水、老和尚饮水问题

**题目：**

   某寺庙，有小和尚、老和尚若干。庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳10桶水，每次入水、取水仅为1桶，不可同时进行。水取自同一井中，水井径窄，每次只能容纳一个水桶取水。设水桶个数为3个，试用信号量和PV操作给出老和尚和小和尚的活动。

**提示：**

从井中取水并放入水缸是一个连续的动作可以视为一个进程，从缸中取水为另一个进程。

设水井和水缸为临界资源，引入mutex1,mutex2；三个水桶无论从井中取水还是放入水缸中都一次一个，应该给他们一个信号量count，抢不到水桶的进程只好为等待，水缸满了时，不可以再放水了。设empty控制入水量，水缸空了时，不可取水设full。

```c
    int n1 = 10; /*水缸容量*/
    int n2 = 3;  /*水桶数量*/
    semaphore mutex1 = 1; /*水井互斥信号量*/
    semaphore mutex2 = 1; /*水缸互斥信号量*/
    semaphore empty = n1; /*小和尚取水同步信号量*/
    semaphore full = 0;   /*老和尚饮水同步信号量*/
    semaphore count = n2; /*水桶数信号量*/
    void youngMonk(){
        while (1){
            P(empty);
            P(count);
            P(mutex1);
            //小和尚从井中取水
            V(mutex1);
            p(mutex2);
            //小和尚向缸中倒水
            V(mutex2);
            V(count);
            V(full);
        }
    }
    void oldMonk(){
        while (1){
            P(full);
            P(count);
            P(mutex2);
            //老和尚从缸中取水饮用
            V(mutex2);
            V(count);
            V(empty);
        }
    }
```

某寺庙，有小和尚、老和尚若干．庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳 30 桶水，每次入水、取水仅为1 桶，不可同时进行。水取自同一井中，水井径窄，每次只能容纳一个水桶取水。设水桶个数为5 个，试用信号量和PV 操作给出老和尚和小和尚的同步算法。

```c
semaphore mutex1=1,mutex2=1,empty=30,full=0,cnt=5;
/*
mutex1实现从井中取水互斥，mutex2实现从缸中入水/取水互斥；
empty初值为30，指示空缓冲块数目。
full初值为0，指示满缓冲块数目。
cnt为水桶数，只有5个水桶。
*/
void young()//小和尚
{
    p(empty);
    p(cnt);
    p(mutex1);
    从井中取水；
    v(mutex1);
    p(mutex2);
    送水到水缸；
    v(mutex2);
    v(cnt);
    v(full);
}
void senior()//老和尚
{
    p(full);
    p(cnt);
    p(mutex2)
    从缸中取水；
    v(mutex2);
    v(cnt);
    v(empty);
}
void main()
{
    parbegin(young(),senior());
}
```

