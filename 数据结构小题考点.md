# 专业课真题小题考点

## 基础考点

- **评价算法应该从正确性、可读性、健壮性、高效率与低存储需求来考虑**
- **算法具有有穷性、确定性、可行性、输入、输出**
- **数据的存储结构主要有顺序存储、链式存储、索引存储、散列存储**
- **一个抽象数据类型包括数据元素，元素之间的关系以及<u>元素的操作</u>**
- **记录是文件中可存取的基本单位，数据项是文件中可使用的最小单位**
- **数据结构中被定义成（K,B），其中K是<u>数据元素</u>的有限集合，R是K上的关系有限集合**

### 指针

- :star::warning::warning:设int b[3] [ 3 ];则数组元素b[1] [2]用指针表示为：` *(*(b + 1) + 2) ` =========>即`b[i][j]` 用指针表示为：`*(*(b + i) + j)`
  - **本题解题步骤：**
    - **`b+i`=>指针 `b` 向后移动 `i` 行。**
    - **`*(b+i)`表示对i行的首地址**
    - **`*(b + 1) + 2` 表示第 1 行第 2 列元素的地址**
    - **`*(*(b + 1) + 2)`表示对第一行第二列元素解引用即取值**
  - **补充知识点：**
    - 一维数组：数组名是指向第一个元素的指针。二维数组：数组名是指向数组第一行的指针，即b[0]的指针。

## 线性表

- **n个元素的线性表第i个位置插入元素，平均移动n/2次，需移动n-i+1 次元素**
- **删除含n个元素的线性表第i个位置的元素，平均移动(n-1)/2次，需移动n-i次元素**
- **在插入或删除第一个元素时单链表比顺序表效率高，单链表无需移动元素，仅需修改指针，时间复杂度 O(1)**
  - **若单链表删除中间元素或尾部则需要遍历到该元素才能进行删除，故没有线性表高效**

### 链表

- **在一个附设头结点的双向链表中删除P所指结点的操作是：**
  - **第一步：P->next->Prior = P->Prior；（C的前驱指向A）**
  - **第二步：p->Prior->next=P->next；（A的后继指向C）**
  - 第三步：free(P);    
  - 理解图：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411221538104.png" alt="image-20241122153808990" style="zoom: 60%;" />

- **设指针变量P，指向单链表结点A，指针变量S，指向被插入结点A后面的操作为：s-->next=p-->next**

## 栈和队列

- **会考前后缀表达式计算  （前缀：从后往前，后入栈放前面进行运算 ，后缀：从前往后，先入栈放前面进行运算）**
- **限定仅在表尾进行插入和删除操作的线性称为栈，修改原则为后进先出**
- 

### 循环队列

- **若题设中具有MAXSIZE个单元顺序循环队列，则可用单元为MAXSIZE-1个**

- **循环队列front为队头指针，rear为队尾指针，采用数组elem[n]作为存储空间：**
  - **队列长度（队伍元素个数）：（rear+n-front）%n --------> (rear+QUEUEMAX-front)%QUEUEMAX**
  - **队满条件：（rear+1）%n==front--------->(rear+1)%QUEUEMAX==front**
  - **队空条件：rear==front**

## 数组与广义表

- **对称矩阵压缩存储成数组，则数组长度为n(n+1)/2**
- **广义表的长度可以通过转换成树数其o结点的最大层数或者通过数最深嵌套层的括号数**

## 串

- **主串长度为n，子串长度为m，则简单模式匹配的最坏时间复杂度为O（nm）,KMP算法时间复杂度为O（n+m）**
- 

## 树与二叉树

- **树中结点数为所有度数之和（度数*度的个数）+1**

- **高度为n的满二叉树，其结点总数为2^n -1**
- **完全二叉树边号为i的结点的双亲结点为：i/2（向下取整）**
  - **若编号为i的结点有左孩子，则左孩子结点为2i，若编号为i的结点有右孩子，则右孩子结点的编号为2i+1**

- 哈夫曼树带权路径长度为结点值乘以树的变数（即层数-1）
- **哈夫曼树中叶子结点有n个，则哈夫曼共有2n-1个结点，若转为二叉链表存储时，有效链域为2n-2个（结点数-1），空链域为2n个（总链域（2*总结点数）-有效链域）**

## 图

- **无向图共有n(n-1)/2条边，有向图有n(n-1)条边**

- **无向图n个顶点，要使得无向图为连通图，则至少为n-1条边，若是无向图为非连通图则最多可能有n(-1)(n-2)/2** 

  -  **对于n个顶点的有向图G，若G是强连通图，则最少有n条边(形成回路)。**

- **无向图邻接表有m个边表结点，则无向图边的数为m/2，（无向图边数为边表结点个数一半）**

  - **有向图：边等于边表结点数目**

- **若无向连通图包含n个顶点，则对应的生成树为n-1条边**

- **一个图的邻接矩阵表示法是唯一，邻接表不唯一**

- **在图中所有顶点度数之等于所有边数的2倍**

  

## 查找

- **查找方法中，平均查找长度与结点个数n无关的是散列表查找**
- 对**顺序表进行折半查找**时，该表必须以**顺序方式存储，且结点按关键字有序排序**
  - **顺序表相关知识点**：
  - **找第i个元素需要比较的次数：n-i+1**
  - **如果要找的不在表中则比较次数为（查找失败）：n+1**
  - **长度为n的顺序表，查找任一元素平均查找长度为(ASL)：(n+1)/2**
  - **时间复杂度：0(n)**
- **二分查找（折半查找）查找成功的平均查找长度ASL ≈ log₂(n+1)-1，时间复杂度为O（log₂n）**

## 排序

- **待排序列较多（n较大），且需挑选前十个最大元素，选择堆排序**
- 若n很大，记录的关键字很少，且可以分解时，采用基数排序
- 若n较小，可采用直接插入排序和简单选择排序
- 关键字基本有序，则选用直接插入或者冒泡排序，其中直接插入比较次数较少
- **要求排序稳定，且时间复杂度为O(nlog2n)，则可以选择归并排序**
- 若n较大且时间复杂度为O(nlog2n)，则可以选择快速排序、堆排序、归并排序
- **排序记录数较大且排序关键字比较随机，无稳定性要求，则应采用快速排序**
- 快速排序被认为是目前基于比较的内部排序方法中最好的方法。待排序的关键字随机分布时,快速排序的平均时间最短
- 若记录本身量较大，避免移动元素浪费时间，可采用链式存储结构

------

- **不稳定：快些选一堆好友来聊天（快速 希尔 选择 堆排序）**

- **平均时间复杂度较快：快些归队（快速 希尔 归并 堆排序）**

- **每一趟至少确定一个元素位置：快确定选一堆帽子（快速 选择 堆 冒泡排序）**

- **与初始序列无关：**

  - **移动次数无关 ：基数排**

  - **比较次数无关 ：选堆归折**

  - **时间复杂度无关：选堆归基**

  - **排序趟数无关：选插归基**、

- **与初始序列有关：冒泡、快速**

- ------

  **简单选择排序：比较次数始终为n(n-1)/2，选择或交换次数为n-1 次**

- **m路归并排序，每选出一个元素需要比较m-1次，冒泡排序所需要最少的比较次数为n-1**

- **基数排序不是基于比较的排序算法**

- **n个结点的二叉排序树，平均情况时间复杂度为O（log₂n）,最坏情况下为O(n)**

### 时间、空间复杂度

- **快速排序**--**最好情况:O(nlog2n) ，平均情况O(nlog2n)**， 最坏情况O(n^2)  ,**空间复杂度为O(log2n)** 
- **堆排序---最好情况、平均情况以及最坏情况时间复杂度均为O(nlog2n)。空间复杂度为O(1)，即需要一个辅助单元**
