# 专业课真题小题考点

## 基础考点

- **评价算法应该从正确性、可读性、健壮性、高效率与低存储需求来考虑**
- **算法具有有穷性、确定性、可行性、输入、输出**
- **数据的存储结构主要有顺序存储、链式存储、索引存储、散列存储**
- **记录是文件中可存取的基本单位，数据项是文件中可使用的最小单位**
- **数据结构中被定义成（K, B），其中 K 是 <u> <span style="color:#FF0000;"> 数据元素 </span> </u> 的有限集合，R 是 K 上的关系有限集合**
  - **数据结构是带有结构的数据元素集合**

- **数据元素是数据基本单位，<span style="color:#FF0000;"> 一个数据元素可用若干数据项组成 </span>**，数据项是数据的不可分割的最小单位
- :star:**抽象数据类型一个特点是抽象数据类型的用户看不到抽象数据类型的 <u> 数据存储 </u> 及其 <u> 操作 </u> 的实现**
  - **一个抽象数据类型包括数据元素，元素之间的关系以及 <u> <span style="color:#FF3333;"> 元素的操作 </span> </u>**
  - **一个抽象数据类型 <span style="color:#FF0000;"> 包括数据和操作两个部分 </span>**

- **数据对象：具有相同特征的数据元素的集合**
- **逻辑结构包含：线型和非线型，其中非线型包括：集合、树型、图型。**
- **算法的五个特征：**
  - **有穷性：保证在 <span style="color:#FF0000;"> 有限步骤 </span> 之后结束，并不是无限** 
  - 确定性：算法每一个指令都必须有明确的含义 不能是模棱两可
  - **可行性：每个操作步骤的必须在 <span style="color:#FF0000;"> 有限时间 </span> 完成**
  - 输入：算法可以有一个或多个输入，也可以没有输入
  - 输出：可以有一个或多个输出，没有输出的算法是没有意义的

### c 语言

- **在 C 语言中整型、字符型、float 型号关系：整型+float 型 = float 型 、整型 *字符型 = 整型 、字符型+float 型 = float 型**
  - **从大到小关系为：float 型 > 整型 > 字符型**
- **if 语句后面的判断条件可以跟任意表达式**
- **常量指针不能进行自增或自减运算；`&s` 返回的是整个数组的地址，也不能进行加减运算**
- **文本文件存储**：
- eg：-8765 在文本文件中存储为字符串 "-8765"，包含 5 个字符：负号(1 字节) + 8(1 字节) + 7(1 字节) + 6(1 字节) + 5(1 字节)
  - **每个 ASCII 字符占 1 字节，共需 5 字节**

- **二进制文件存储：**
- **-8765 用二进制存储时，因为在 16 位整型范围，只需要 2 字节(16 位)就能表示 [-32768, 32767]**

#### 运算符表达式？？？？

#### 指针

- :star::warning::warning:设 int b [3] [ 3 ]; 则数组元素 b [1] [2] 用指针表示为：` *(*(b + 1) + 2) ` ==== ==== => 即 `b[i][j]` 用指针表示为：`*(*(b + i) + j)`
  - **本题解题步骤：**
    - **`b+i` => 指针 `b` 向后移动 `i` 行。**
    - **`*(b+i)` 表示对 i 行的首地址**
    - **`*(b + 1) + 2` 表示第 1 行第 2 列元素的地址**
    - **`*(*(b + 1) + 2)` 表示对第一行第二列元素解引用，即取值**
  - **补充知识点：**
    - **一维数组：数组名是指向第一个元素的指针**。**二维数组：数组名是指向数组第一行的指针，即 b [0] 的指针。**
- **对于一个具 n 个结点的线性链表，在已知的结点 `*p` 后插入一个新结点的时间复杂性为 O(1)**
  - **已知  *p（若改为&p 一样），意味着我们已经有办法直接访问到 p 所指向的内存地址，则不用遍历到该结点所在位置**。
  - 
- <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231657287.png" alt="image-20241123165741239" style="zoom:80%;" /> **解析：因为 <span style="color:#FF0000;"> s 是二级指针，不能直接赋值字符串常量 </span>，只能有 `*s = "hello"` 或 `**s = 'h'` **
  - **若题目改成一级指针 char *s，<span style="color:#FF3333;"> `*S` 表示 `S` 所指向的地址的内容，默认指向第一个字母 </span>，则正确的语句为 `*s = 'h'`**



## 线性表

- **n 个元素的线性表第 i 个位置插入元素，平均移动 `n/2` 次，需移动 `n-i+1 ` 次元素**
- **删除含 n 个元素的线性表第 i 个位置的元素，平均移动 `(n-1)/2` 次，需移动 `n-i` 次元素**
- **<span style="color:#FF0000;"> 在插入或删除第一个元素 </span> 时单链表比顺序表效率高，单链表无需移动元素，仅需修改指针，时间复杂度 O(1)**
  - **若单链表删除中间元素或尾部则 <span style="color:#FF0000;"> 需要遍历到该元素才能进行删除 </span>，故没有线性表高效**
  - <span style="color:#FF0000;">**总结：链式存储在插入和删除操作方面具有较高的效率，只需要修改指针链接即可。而顺序存储在插入和删除操作方面效率较低，因为它需要移动大量元素以保持数据的连续性**</span>
    - <span style="color:#FF0000;">**顺序表适宜于做查找这样的静态操作，顺序存储：访问某一结点、查找某结点前驱、删除尾结点的时间复杂度都是O（1）**</span>

### :star:链表

1. **在一个附设头结点的双向链表中删除 P 所指结点的操作是：**
  - **第一步：p-> Prior-> next = P-> next；（A 的后继指向 C）**
  - **第二步：P-> next-> Prior = P-> Prior；（C 的前驱指向 A）【从左到右写】**
  - 第三步：free(P);    
    - 理解图：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411221538104.png" alt="image-20241122153808990" style="zoom: 60%;" /> p 默认指向 B

2. **设指针变量 P，指向单链表结点 A，指针变量 S，指向被插入结点 A 后面的结点，则操作为：s--> next = p--> next、P-> next = S;**
3. **设指针变量 p 指向双向链装中结点 A，指针变量 q 指向被插入结点 B，要求给出在结点 A 的后面插入结点 B 的操作序列(设双向链装中结点的两个指针域分别为 left 和 right)：**
   - **q-> left = p ---让B的左手指向A **
   - **q->right=p->right---让B的右手指向C**
   - **p-> right-> left = q 让C的左边指向B，此时A还是指向C**
   - **p->right=s ------- 更新A的指向，让其指向B**   
     - **顺序是固定且不能变**
     - **若题目中是删除结点 B，则分为两步：**
       - **p-> right = q-> right **
   
       - **q-> right-> left = p **
   - **大总结：插入四步，删除两步**
     - **插入顺序：前两步是让新插入的结点B分别和A，C两边连接，后两步是更新A，C指向，使其指向B**
     - **删除顺序：先删除A和B之间的连接，让A的后继指向C，然后让C的前驱指向A**


## 栈和队列

- **会考前后缀表达式计算  （前缀：从后往前，后入栈放前面进行运算 ，后缀：从前往后，先入栈放前面进行运算）**
- **限定 <span style="color:#FF0000;"> 仅在表尾进行插入和删除操作的线性表称为栈 </span>，修改原则为后进先出**
  - AZ<span style="color:#FF0000;"> **队列是表头删除，表尾插入** </span>


### 循环队              列

**:star:若题设中具有 MAXSIZE 个单元顺序循环队列，则可用单元为 MAXSIZE-1 个**

- **具有 n 个单元的循环队列，队满时共有 n-1 个元素**
  - <span style="color:#FF0000;"> **若题目中没说明 rear 和 front 的时候，可用单元和队满元素个数均为 n-1 或 MAXSIZE-1** </span>

**循环队列 front 为队头指针，rear 为队尾指针，采用数组 elem [n] 作为存储空间：**

- **队列长度（队伍元素个数）：<span style="color:#FF0000;">（rear+n-front）%n </span>**
- **队满条件：<span style="color:#FF0000;">（rear+1）%n == front </span> **
- **队空条件：<span style="color:#FF0000;"> rear == front </span> **
- **循环队列中插入或删除元素时；操作：<u> 在尾结点后插入，在首结点处删除 </u>，指针按顺时针方向进 1,**
- 
  - **删除（出队）：**
    - <span style="color:#FF0000;"> **front =(front+1)% QUEUEMAX** </span>
    - **删除操作不改变 `rear` 的位置。**
  - **插入（入队）：**
    - <span style="color:#FF0000;"> **rear =(rear+1)% QUEUEMAX** </span>
    - **插入操作不改变 `front` 的位置。**

## 数组与广义表

- **对称矩阵压缩（一般为下三角矩阵压缩）存储成数组，则数组长度为 n(n+1)/2，下三角矩阵元素为 n²**
  - **若为上三角矩阵压缩**，如题所示（19 年）：
    - <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231647527.png" alt="image-20241123164707458" style="zoom:60%;" />
    - 答案：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231648558.png" alt="image-20241123164804502" style="zoom:60%;" />
      - **带权有向图，且没有提到自环的存在。因此，所有的顶点 i 到自身 i 的权值默认为 0。**
- **广义表的长度可以通过转换成树，其深度为其树中 o 结点的所在的 <span style="color:#FF0000;"> 最大层数 </span> 或者通过数出最深嵌套层的括号数**
- **稀疏矩阵通常使用三元组和十字链表法**-
- :star:**三元组存储稀疏矩阵所需字节数：设有 n 个非零元素则所需字符数为 `(n+1)*3*每个元素所占字节数`**

### **需记公式**

#### 二维数组的存储

##### 行优先

- <span style="font-size:1.2em;">**下标从0开始：`loc(aij) = loc(a0,0)+[i*n+j]*d` -----n为总列数**</span>
- <span style="font-size:1.2em;">**下标不从0开始：`loc(aj) = loc(c1,c2)+[(i-c1)*(d2-c2+1)+(j-c2)]*d`**</span>

##### 列优先

- <span style="font-size:1.1em;">**下标从0开始：`loc(aij) = loc(a0,0)+[i*n+j]*d`-------   m为总行数**</span>
- <span style="font-size:1.1em;">**下标不从0开始：`loc(aj) = loc(c1,c2)+[(j-c2)*(d1-c1+1)+(i-c1)]*d`**</span><span style="font-size:1.3em;"></span>

#### 三角矩阵的压缩存储

- **三角矩阵均为n阶方阵**
- 按行序存储，`a[i][j]与s[k]的对应方式`：**下标均从0开始**

$$
下三角： k=i(i+1)/2+j  \\
上三角：k=n(n+1)/2\\
计算地址：loc(aij) = loc(a0,0)+[i(i+1)/2+1]*d
$$

<span style="font-size:1.2em;">	**对于<span style="color:#FF0000;">对称矩阵的下三角公式也按此存储方法</span>，即：`a[i][i]=i(i+1)/2 +i=i(i+3)/2`**</span>

​	**注：若矩阵下标从1开始，则`i和j减1`，若压缩到的数组从1开始，则算出来的`k再加1`**

![image-20241125191047920](https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411251910036.png)

#### 对角矩阵的压缩存储

**非零元素分布在主对角线上和其他对角线上，其余元素为0**

**地址计算：**

- 用一维数组存储，<span style="font-size:1.2em; font-weight:bold;">`k=i(2b+1)+j-i`（下标均从0开始）</span>
- **<span style="font-size:1.1em;">地址计算：`loc(aij) = loc(a0,0)+[i(2b+1)+j-i]*d`</span>**
  - ​	**注：若矩阵下标从1开始，则`i和j减1`，若压缩到的数组从1开始，则算出来的`k再加1`**





## 串

- **主串长度为 n，子串长度为 m，则简单模式匹配的最坏时间复杂度为 O（nm）, KMP 算法时间复杂度为 O（n+m）**
- **串既可以链式存储也可以顺序存储**
- **串是字符的有限序列，空串是不包含任何字符组成的串，由空格组成的串是空格串**
- **串中字符均不相同，由n个字符组成的串，其含子串`n(n+1)/2 +1`**

## 树与二叉树

- **树中结点数为所有度数之和（度数 *度的个数）+1**

- **高度为 n 的满二叉树，其结点总数为 2^n -1**
- **完全二叉树边号为 i 的结点的双亲结点为：i/2（向下取整）**
  - **若编号为 i 的结点有左孩子，则左孩子结点为 2i，若编号为 i 的结点有右孩子，则右孩子结点的编号为 2i+1**

- **:star:完全二叉树深度： ┗  log2 n ┛+1  或 ┏ log2 (n+1) ┓**
  
- **哈夫曼树带权路径长度（wpl）为结点值乘以树的变数（即层数-1）**
- **:star:哈夫曼树中叶子结点有 n 个，则哈夫曼共有 2n-1 个结点，若转为二叉链表存储时，有效链域为 2n-2 个（结点数-1），空链域为 2n 个（总链域（2 *总结点数）-有效链域）**
- **:star::star:判断是否是前缀编码：**
  - <u> **在编码方案中，任何一个编码都不是其他任何编码的前缀，即一个编码不能以另一个编码作为开头或者完全一样。（例：110 和 1100，1100 包含了 110，即不是前缀比编码）** </u>
- **先序森林等同于先序遍历二叉树，先序树等先序二叉树**
  - **后序森林等于中序二叉树 ，后序树等于中序二叉树，后序树等于中序森林**

- **:star:二叉排序树的三种情况**
  - **若是删除叶子结点则直接进行删除**
  - **若删除结点有右子树就用右子树的值来进行替换，左子树同理**
  - **若删除结点有左右子树，则用右边靠近该结点的第一个中序元素**
- **线索二叉链表树：孩子为 1，线索为 0，缺左子树指向中序前一个，缺右子树指向中序后一个**
- **高度为 h 的 m 叉树的至多有(m^h-1)/(m-1)个结点-----一般是给树的结点数量用于求叉树的高度**

## **图**

- **完全无向图共有 n(n-1)/2 条边，完全有向图有 n(n-1)条边。**
  - **若题目中给出为非连通无向图，则顶点数量，需要额外+1**

  - **:warning:e.g.：若G非连通无向图共有28条边，则该图至少与多少个顶点----------根据n(n+1)/2得出n为8，但为非连通则需额外+1，顶点数至少为9.**

- **无向图 n 个顶点，要使得无向图为连通图，则至少为 n-1 条边，若是无向图为非连通图则最多可能有 n(-1)(n-2)/2** 
  -  **对于 n 个顶点的有向图 G，若 G 是强连通图，则最少有 n 条边(形成回路)。**

- **无向图邻接表有 m 个边表结点（非零元素个数），则无向图边的数为 m/2，（无向图边数为边表结点个数一半）**-----------**有向图：边等于边表结点数目，e 条边即 e 条边表结点个数**
  - **无向图邻接矩阵零元素个数为 n²-2e**

  - **有向图邻接矩阵元素个数为 n²-e**

- **若无向连通图包含 n 个顶点，则对应的生成树为 n-1 条边**

- **一个图的邻接矩阵表示法是唯一，邻接表不唯一**

- **在图中所有顶点度数之等于所有边数的 2 倍**

### 最短路径？？？？？？？？？

- #### 迪杰斯特拉算法

- #### Floyd 算法？？？？？？

### 关键路径 ？？？？？？？



## 查找

### 常考点

- **查找方法中，平均查找长度与结点个数 n 无关的是散列表查找**
- **折半查找和顺序查找都是有序查找**
- 对 **顺序表进行折半查找** 时，该表必须以 **顺序方式存储，且结点按关键字有序排序**
  - **顺序表相关知识点**：
  - **找第 i 个元素需要比较的次数：n-i+1**
  - **如果要找的不在表中则比较次数为（查找失败）：n+1**
  - **长度为 n 的顺序表，查找任一元素平均查找长度为(ASL)：(n+1)/2**
  - **时间复杂度：0(n)**
- **二分查找（折半查找）查找成功的平均查找长度，用判定树来进行计算，即 `树的结点*树的层数/元素个数` 时间复杂度为 O（log₂n）**
- **n 个结点的二叉排序树，平均情况时间复杂度为 O（log₂n）, 最坏情况下为 O(n)**
- **二叉排序树的进行中序遍历，得到的结点序列一定是个有序序列**

### 顺序查找

顺序查找适合于顺序表和链表，**属于无序查找**，**从后往前开始**

- **找第 i 个元素需要比较的次数：n-i+1**
- **如果要找的不在表中则比较次数为（查找失败）：n+1**
- **长度为 n 的顺序表，查找任一元素平均查找长度为(ASL)：(n+1)/2**
  - **若题目中没说是顺序表则平均查找长度为 n/2**

- **时间复杂度：0(n)**

**优缺点：适用范围大，元素无次序  ，当 n 较大时效率较低**

 **注意：**

- **单链表和顺序表实现时间复杂度都为 O(n)，但**
- **删除第一个元素时，单链表可直接删除不需要移动元素，而顺序表删完后需要移动元素，所需时间更多，故此情况下单链表时间快**
- **若在最后一个元素插入一个新的元素，单链表需要遍历到最后一个元素才能进行插入，而顺序表仅需根据下标即可，不需要移动元素，即顺序表速度大于单链表速度**
- **若交换两个元素，单链表均需要遍历到该元素位置才能完成交换，而顺序表无需遍历，仅根据下标即可完成，故顺序表速度快**

### 折半查找 （二分查找） ┗   ┛   ┏    ┓

**适用于有序查找** 

**<span style="text-decoration:line-through;"> 查找成功的平均查找长度 ASL ≈ log₂(n+1)-1 </span>，时间复杂度为 O（log₂n）**

**【注：若题目中问平均查找长度一般用判定树来进行计算，查找成功长度为（每层结点个数 * 树的层数）/结点个数】**

- 确定中间位置为 mid =  **┗  (low+high)  / 2 ┛（向下取整）**
- **若中间位置等于待查数字之 4 则查找成功，若中间位置值小于待查数字值，则 low = mid + 1    若中间位置值大于待查数字值，则 high = mid - 1**

**优缺点：比较次数少，查找速度相对快，查找前需要建立有序表，适用范围少，并不是一定比顺序查找速度快**

#### 折半查找判定树

**折半查找判定树是一颗平衡二叉树，其核心思想同二叉排序树一致，（核心思想：中间大的放中间，最小的放左子树，最大的放右子树）**

**判定树的高度为：h =   ┗ log₂n ┛  + 1 或者 h = ┏ log₂(n+1) ┓，比较成功时，同关键字比较次数最多为 h，时间复杂度为 O（log₂n）**

例，若有 1000 个元素，则采用折半查找则至多比较 **┏ log₂(1000+1) ┓ 次** 数

#### 构建判定树快速法

1. **根据元素数量，画出二叉树，每次先画右子树，把每行的右结点的右子树都画完时，再画左结点的右子树，当每行右子树都画完时，然后再按量添加左子树（均是从右往左）**
2. **画完二叉树，然后按照有序序列的中序便利进行填充**

**补充：**

- **查找元素需要与哪些元素进行比较时，可按照二叉排序树的插入进行比较，（从根节点开始，若大于根节点则从右子树开始比较，若小于根节点则从左子树开始比较，依次递归，直到查找完成）**
- **其中 ASL 查找成功和失败按照二叉排序树的查找成功失败来进行计算**

### 分块查找（索引查找）

**分块查找又成索引顺序查找，原始序列可以无序，将其进行分块，不一定要进行等分，选择每个块中最大的元素放入一张索引表，并记录该元素的地址，索引表内元素需有序**

**若表长度为 n，每个子表的长度相等，设为 s，则进行成功查找的平均查找长度为：(k+n/k) / 2 +1**

## 排序

- **待排序列较多（n 较大），且需挑选前十个最大元素，选择堆排序**
- 若 n 很大，记录的关键字很少，且可以分解时，采用 **基数排序（不用比较）**
- 若 n 较小，可采用直接插入排序和简单选择排序
- 关键字基本有序，则选用直接插入或者冒泡排序，其中直接插入比较次数较少
- **要求排序稳定，且时间复杂度为 O(nlog2n)，则可以选择归并排序**
- **若 n 较大且时间复杂度为 O(nlog2n)，则可以选择快速排序、堆排序、归并排序**
- **排序记录数较大且排序关键字比较随机，无稳定性要求，则应采用快速排序**
- **快速排序被认为是目前基于比较的内部排序方法中最好的方法。待排序的关键字随机分布时, 快速排序的平均时间最短**
- 若记录本身量较大，**避免移动元素浪费时间，可采用链式存储结构**

------

- **不稳定：快些选一堆好友来聊天（快速 希尔 选择 堆排序）**
- **平均时间复杂度较快：快些归队（快速 希尔 归并 堆排序）**
- **每一趟至少确定一个元素位置：快确定选一堆帽子（快速 选择 堆 冒泡排序）**
- **与初始序列无关：**
  - **移动次数无关 ：基数排**
  
  - **比较次数无关 ：选堆归折**
  
  - **时间复杂度无关：选堆归基**
  
  - **排序趟数无关：选插归基**、
- **与初始序列有关：冒泡、快速------> 易受初始序列影响**
- **:star::star:对于对堆排序和快排，若原始停列记录接近有序，则选堆排序。**

  - <u> **如果题目中有冒泡排序，则优先选冒泡排序，如果有直接插入排序，则最先选直接插入排序** </u>
    - **冒泡排序在有序的情况下性能极佳，此时时间复杂度为 O(n)**
    - **:star:对于接近有序的序列，速度快：直接插入排序-> 冒泡排序-> 堆排序-> 选择排序-> 快速排序**
- **在堆排序中，关键字递增（从小到大），则初始堆建立大根堆。若关键字递减（从大到小），则建立小根堆。**

- ------

  **简单选择排序：比较次数始终为 n(n-1)/2，选择或交换次数为 n-1 次**

- **m 路归并排序，每选出一个元素需要比较 m-1 次，冒泡排序所需要最少的比较次数为 n-1**

- **基数排序不是基于比较的排序算法**

- **n 个结点的二叉排序树，平均情况时间复杂度为 O（log₂n）, 最坏情况下为 O(n)**

### 时间、空间复杂度

- **折半插入排序 ---平均时间复杂度为 O(log2n)** 

- **快速排序**--**最好情况: O(nlog2n) ，平均情况 O(nlog2n)**， 最坏情况 O(n^2)  , **空间复杂度为 O(log2n)** 
- **堆排序---最好情况、平均情况以及最坏情况时间复杂度均为 O(nlog2n)。空间复杂度为 O(1)，即需要一个辅助单元**
- **快速排序、堆排序、归并排序三种排序平均和最好情况都是 O(nlog2n)，但快速排序最坏情况是 O(log2n)，其余两种最坏也是 O(nlog2n)。** 而且这三种排序，**堆排序占额外空间最小为 O(1)**

​                 
