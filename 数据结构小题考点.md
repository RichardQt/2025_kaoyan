# 专业课真题小题考点

## 基础考点

- **评价算法应该从正确性、可读性、健壮性、高效率与低存储需求来考虑**
- **算法具有有穷性、确定性、可行性、输入、输出**
- **数据的存储结构主要有顺序存储、链式存储、索引存储、散列存储**
- **一个抽象数据类型包括数据元素，元素之间的关系以及<u>元素的操作</u>**
- **记录是文件中可存取的基本单位，数据项是文件中可使用的最小单位**
- **数据结构中被定义成（K,B），其中K是<u>数据元素</u>的有限集合，R是K上的关系有限集合**
- **数据元素是数据基本单位，一个数据元素可用若干数据项组成**
- :star:**抽象数据类型一个特点是抽象数据类型的用户看不到抽象数据类型的<u>数据存储</u>及其<u>操作</u>的实现**
  - **一个抽象数据类型包括数据和操作两个部分**

- **数据对象：具有相同特征的数据元素的集合**
- **逻辑结构包含：线型和非线型，其中非线型包括：集合、树型、图型。**
- 数据存储结构主要有：顺序存储、链式存储、索引存储、散列存储
- **算法的五个特征：**
  - **有穷性：保证在有限步骤之后结束 不是无限** 
  - 确定性：算法每一个指令都必须有明确的含义 不能是模棱两可
  - **可行性：每个操作步骤的必须在有限时间完成**
  - 输入：算法可以有一个或多个输入，也可以没有输入
  - 输出：可以有一个或多个输出，没有输出的算法是没有意义的

### c语言

- **在C语言中整型、字符型、float型号关系：整型+float型 = float型 、整型*字符型 = 整型 、字符型+float型 = float型**
  - **从大到小关系为：float型 > 整型 > 字符型**
- **if语句后面的判断条件可以跟任意表达式**
- **常量指针不能进行自增或自减运算；`&s` 返回的是整个数组的地址，也不能进行加减运算**

#### 指针

- :star::warning::warning:设int b[3] [ 3 ];则数组元素b[1] [2]用指针表示为：` *(*(b + 1) + 2) ` =========>即`b[i][j]` 用指针表示为：`*(*(b + i) + j)`
  - **本题解题步骤：**
    - **`b+i`=>指针 `b` 向后移动 `i` 行。**
    - **`*(b+i)`表示对i行的首地址**
    - **`*(b + 1) + 2` 表示第 1 行第 2 列元素的地址**
    - **`*(*(b + 1) + 2)`表示对第一行第二列元素解引用即取值**
  - **补充知识点：**
    - 一维数组：数组名是指向第一个元素的指针。二维数组：数组名是指向数组第一行的指针，即b[0]的指针。
- **对于一个具n个结点的线性链表，在已知的结点`*p`后插入一个新结点的时间复杂性为O(1)**
  - **已知  *p（若改为&p一样），意味着我们已经有办法直接访问到 p 所指向的内存地址，则不用遍历到该结点所在位置**。
  - 
- <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231657287.png" alt="image-20241123165741239" style="zoom:80%;" />解析：
  - 



## 线性表

- **n个元素的线性表第i个位置插入元素，平均移动n/2次，需移动n-i+1 次元素**
- **删除含n个元素的线性表第i个位置的元素，平均移动(n-1)/2次，需移动n-i次元素**
- **在插入或删除第一个元素时单链表比顺序表效率高，单链表无需移动元素，仅需修改指针，时间复杂度 O(1)**
  - **若单链表删除中间元素或尾部则需要遍历到该元素才能进行删除，故没有线性表高效**

### 链表

- **在一个附设头结点的双向链表中删除P所指结点的操作是：**
  - **第一步：P->next->Prior = P->Prior；（C的前驱指向A）**
  - **第二步：p->Prior->next=P->next；（A的后继指向C）**
  - 第三步：free(P);    
  - 理解图：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411221538104.png" alt="image-20241122153808990" style="zoom: 60%;" />

- **设指针变量P，指向单链表结点A，指针变量S，指向被插入结点A后面的操作为：s-->next=p-->next**

## 栈和队列

- **会考前后缀表达式计算  （前缀：从后往前，后入栈放前面进行运算 ，后缀：从前往后，先入栈放前面进行运算）**
- **限定仅在表尾进行插入和删除操作的线性称为栈，修改原则为后进先出**
- 

### 循环队列

**:star:若题设中具有MAXSIZE个单元顺序循环队列，则可用单元为MAXSIZE-1个**

- **具有n个单元的循环队列，队满时共有n-1个元素**
  - **若题目中没说明rear和front的时候，可用单元和队满元素个数均为n-1或MAXSIZE-1**


**循环队列front为队头指针，rear为队尾指针，采用数组elem[n]作为存储空间：**

- **队列长度（队伍元素个数）：（rear+n-front）%n --------> (rear+QUEUEMAX-front)%QUEUEMAX**
- **队满条件：（rear+1）%n==front--------->(rear+1)%QUEUEMAX==front**
- **队空条件：rear==front**
- **循环队列中插入或删除元素时，指针按顺时针方向进1、**
  - **删除（出队）：**
    - **front=(front+1)% QUEUEMAX**
    - **删除操作不改变 `rear` 的位置。**
  - **插入（入队）：**
    - **rear=(rear+1)% QUEUEMAX**
    - **插入操作不改变 `front` 的位置。**

## 数组与广义表

- **对称矩阵压缩（一般为下三角矩阵压缩）存储成数组，则数组长度为n(n+1)/2，下三角矩阵元素为n²**
  - **若为上三角矩阵压缩**，如题所示（19年）：
    - <img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231647527.png" alt="image-20241123164707458" style="zoom:60%;" />
    - 答案：<img src="https://cdn.jsdelivr.net/gh/RichardQt/PicBed/note/202411231648558.png" alt="image-20241123164804502" style="zoom:60%;" />

- **广义表的长度可以通过转换成树，其深度为其树中o结点的所在的最大层数或者通过数出最深嵌套层的括号数**

## 串

- **主串长度为n，子串长度为m，则简单模式匹配的最坏时间复杂度为O（nm）,KMP算法时间复杂度为O（n+m）**
- **串既可以链式存储也可以顺序存储**

## 树与二叉树

- **树中结点数为所有度数之和（度数*度的个数）+1**

- **高度为n的满二叉树，其结点总数为2^n -1**
- **完全二叉树边号为i的结点的双亲结点为：i/2（向下取整）**
  - **若编号为i的结点有左孩子，则左孩子结点为2i，若编号为i的结点有右孩子，则右孩子结点的编号为2i+1**

- **:star:完全二叉树深度： ┗  log2 n ┛+1  或 ┏ log2 (n+1) ┓**
  
- **哈夫曼树带权路径长度（wpl）为结点值乘以树的变数（即层数-1）**
- **:star:哈夫曼树中叶子结点有n个，则哈夫曼共有2n-1个结点，若转为二叉链表存储时，有效链域为2n-2个（结点数-1），空链域为2n个（总链域（2*总结点数）-有效链域）**
- **:star::star:判断是否是前缀编码：**
  - <u>**在编码方案中，任何一个编码都不是其他任何编码的前缀，即一个编码不能以另一个编码作为开头或者完全一样。（例：110和1100，1100包含了110，即不是前缀比编码）**</u>
- **先序森林等同于先序遍历二叉树，后序遍历森林等于中序遍历二叉树**


## **图**

- **无向图共有n(n-1)/2条边，有向图有n(n-1)条边**

- **无向图n个顶点，要使得无向图为连通图，则至少为n-1条边，若是无向图为非连通图则最多可能有n(-1)(n-2)/2** 

  -  **对于n个顶点的有向图G，若G是强连通图，则最少有n条边(形成回路)。**

- **无向图邻接表有m个边表结点，则无向图边的数为m/2，（无向图边数为边表结点个数一半）**

  - **有向图：边等于边表结点数目**

- **若无向连通图包含n个顶点，则对应的生成树为n-1条边**

- **一个图的邻接矩阵表示法是唯一，邻接表不唯一**

- **在图中所有顶点度数之等于所有边数的2倍**

### 最短路径？？？？？？？？？

- #### 迪杰斯特拉算法

- #### Floyd算法？？？？？？

### 关键路径 ？？？？？？？



## 查找

- **查找方法中，平均查找长度与结点个数n无关的是散列表查找**
- **折半查找和顺序查找都是有序查找**
- 对**顺序表进行折半查找**时，该表必须以**顺序方式存储，且结点按关键字有序排序**
  - **顺序表相关知识点**：
  - **找第i个元素需要比较的次数：n-i+1**
  - **如果要找的不在表中则比较次数为（查找失败）：n+1**
  - **长度为n的顺序表，查找任一元素平均查找长度为(ASL)：(n+1)/2**
  - **时间复杂度：0(n)**
- **二分查找（折半查找）查找成功的平均查找长度ASL ≈ log₂(n+1)-1，时间复杂度为O（log₂n）**

## 排序

- **待排序列较多（n较大），且需挑选前十个最大元素，选择堆排序**
- 若n很大，记录的关键字很少，且可以分解时，采用**基数排序（不用比较）**
- 若n较小，可采用直接插入排序和简单选择排序
- 关键字基本有序，则选用直接插入或者冒泡排序，其中直接插入比较次数较少
- **要求排序稳定，且时间复杂度为O(nlog2n)，则可以选择归并排序**
- **若n较大且时间复杂度为O(nlog2n)，则可以选择快速排序、堆排序、归并排序**
- **排序记录数较大且排序关键字比较随机，无稳定性要求，则应采用快速排序**
- **快速排序被认为是目前基于比较的内部排序方法中最好的方法。待排序的关键字随机分布时,快速排序的平均时间最短**
- 若记录本身量较大，**避免移动元素浪费时间，可采用链式存储结构**

------

- **不稳定：快些选一堆好友来聊天（快速 希尔 选择 堆排序）**

- **平均时间复杂度较快：快些归队（快速 希尔 归并 堆排序）**

- **每一趟至少确定一个元素位置：快确定选一堆帽子（快速 选择 堆 冒泡排序）**

- **与初始序列无关：**
  - **移动次数无关 ：基数排**
  
  - **比较次数无关 ：选堆归折**
  
  - **时间复杂度无关：选堆归基**
  
  - **排序趟数无关：选插归基**、
  
- **与初始序列有关：冒泡、快速------>易受初始序列影响**

- **:star::star:对于对堆排序和快排，若原始停列记录接近有序，则选堆排序。**

  - **如果题目中有冒泡排序，则优先选冒泡排序**
    - **冒泡排序在有序的情况下性能极佳，此时时间复杂度为O(n)**

- ------

  **简单选择排序：比较次数始终为n(n-1)/2，选择或交换次数为n-1 次**

- **m路归并排序，每选出一个元素需要比较m-1次，冒泡排序所需要最少的比较次数为n-1**

- **基数排序不是基于比较的排序算法**

- **n个结点的二叉排序树，平均情况时间复杂度为O（log₂n）,最坏情况下为O(n)**

### 时间、空间复杂度

- **折半插入排序 ---平均时间复杂度为O(log2n)** 

- **快速排序**--**最好情况:O(nlog2n) ，平均情况O(nlog2n)**， 最坏情况O(n^2)  ,**空间复杂度为O(log2n)** 
- **堆排序---最好情况、平均情况以及最坏情况时间复杂度均为O(nlog2n)。空间复杂度为O(1)，即需要一个辅助单元**
- **快速排序、堆排序、归并排序三种排序平均和最好情况都是O(nlog2n)，但快速排序最坏情况是O(log2n)，其余两种最坏也是O(nlog2n)。**而且这三种排序，**堆排序占额外空间最小为O(1)**

​                 
